{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Project Reeve: The \"Chief of Staff\" Protocol","text":"<p>A proactive AI assistant that operates on a \"Push\" paradigm - anticipating needs and taking action rather than waiting for prompts.</p> <p>Quick Links: GitHub | Installation | Architecture | Roadmap | MCP Setup | Ideas &amp; Future | Discussions | Contributing</p>"},{"location":"#documentation-overview","title":"Documentation Overview","text":""},{"location":"#architecture","title":"Architecture","text":"<p>Technical documentation for the pulse queue system:</p> Document Description Architecture Index Overview of all architecture docs Project Structure Directory layout and file organization Pulse Queue Design Database schema, models, queue logic MCP Integration MCP server specifications Daemon &amp; API Daemon orchestration and HTTP API Deployment Production deployment guide"},{"location":"#implementation-roadmap","title":"Implementation Roadmap","text":"<p>Phase-by-phase implementation guide:</p> Phase Document Status 1 Foundation Completed 2 Queue Management Completed 3 MCP Servers Completed 4 Pulse Executor Completed 5 Daemon Completed 6 HTTP API Completed 7 Telegram Integration Completed 8 Deployment Pending 9 Testing &amp; Polish Pending <p>See Roadmap Index for the full implementation guide.</p>"},{"location":"#other-resources","title":"Other Resources","text":"<ul> <li>MCP Setup Guide - Configuring MCP servers for Claude Code</li> <li>OpenClaw Comparison - Architectural comparison with OpenClaw</li> <li>Ideas &amp; Future - Exploratory ideas and future concepts</li> </ul>"},{"location":"#how-reeve-works","title":"How Reeve Works","text":""},{"location":"#conceptual-overview","title":"Conceptual Overview","text":"<p>The Desk is Reeve's brain, wake-ups are its heartbeat, and everything flows through you.</p> <pre><code>%%{init: {'theme': 'base', 'flowchart': {'rankSpacing': 50}}}%%\nflowchart TB\n    classDef user fill:#8b6aad,stroke:#6b4a8d,color:#fff\n    classDef brain fill:#c4955a,stroke:#a67940,color:#fff\n    classDef core fill:#4a90a4,stroke:#2e6b7a,color:#fff\n    classDef ext fill:#6b9b76,stroke:#4a7a54,color:#fff\n\n    World[\"\ud83c\udf10 **The World**&lt;br/&gt;Email \u00b7 Texts \u00b7 Calendar \u00b7 Web\"]:::ext\n\n    World --&gt;|\"event\"| Wake{{\"\u26a1 **Wake Reeve**&lt;br/&gt;*heartbeat \u00b7 events \u00b7 alarms*\"}}:::core\n\n    Wake --&gt;|\"starts fresh\"| Reeve[\"\ud83e\udd16 **Reeve**&lt;br/&gt;clean slate each wake-up\"]:::core\n\n    Reeve &lt;--&gt;|\"converses\"| You[\"\ud83d\udc64 **You**\"]:::user\n    Reeve &lt;--&gt;|\"reads &amp;amp; updates\"| Desk[(\"\ud83e\udde0 **The Desk**&lt;br/&gt;Goals \u00b7 Prefs \u00b7 Diary \u00b7 Skills \u00b7 ...&lt;br/&gt;&lt;br/&gt;*plain text files you can edit&lt;br/&gt;Git versioned*\")]:::brain\n    Reeve --&gt;|\"takes action\"| World\n    Reeve -.-&gt;|\"sets own alarms\"| Wake\n\n    You -.-&gt;|\"inspect &amp;amp; edit\"| Desk</code></pre> <p>Key ideas at a glance:</p> <ul> <li>Push, not Pull \u2014 Reeve reaches out with alerts, briefings, and questions. You can reply, approve, or redirect. It's a conversation, not a notification feed.</li> <li>The Desk is the Brain \u2014 A folder of plain text files (Goals, Preferences, Diary, Skills) that Reeve reads on every wake-up and updates with what it learned. Version-controlled so you can undo mistakes.</li> <li>Glass Box \u2014 You can open Reeve's brain, read it, and edit it anytime. No arguing with a chatbot \u2014 just fix the file.</li> <li>Clean Slate \u2014 Every wake-up starts fresh. The Desk is the only thing that carries over, keeping each session focused.</li> <li>Self-Scheduling \u2014 Reeve sets its own future alarms, creating a self-sustaining loop. \"Check flight prices tomorrow at 6am\" \u2014 done.</li> </ul>"},{"location":"#technical-architecture","title":"Technical Architecture","text":"<p>How the components connect under the hood. For implementation details, see Architecture docs.</p> <pre><code>%%{init: {'theme': 'base', 'themeVariables': { 'lineColor': '#888'}}}%%\nflowchart TB\n    %% External event sources\n    telegram[\"Telegram&lt;br/&gt;Listener\"]\n    webhooks[\"3rd Party&lt;br&gt;Webhooks&lt;br/&gt;&lt;i&gt;WIP&lt;/i&gt;\"]\n\n    %% Pulse Daemon internals\n    api[\"Pulse API&lt;br/&gt;&lt;i&gt;FastAPI :8765&lt;/i&gt;\"]\n    queue[(\"Pulse Queue&lt;br/&gt;&lt;i&gt;SQLite&lt;/i&gt;\")]\n    executor[\"Executor\"]\n\n    %% Agent session\n    agent[\"Reeve Agent&lt;br/&gt;&lt;i&gt;Claude Code / Hapi&lt;/i&gt;\"]\n\n    %% MCP Servers\n    pulse_mcp[\"Pulse Queue&lt;br/&gt;MCP\"]\n    notify_mcp[\"Telegram&lt;br/&gt;Notifier MCP\"]\n\n    %% Desk and User\n    DeskRepo[\"\ud83d\udcc2 The Desk&lt;br/&gt;&lt;i&gt;separate Git repo&lt;/i&gt;&lt;br/&gt;Goals/ \u00b7 Responsibilities/&lt;br/&gt;Preferences/ \u00b7 Diary/ \u00b7 Skills/\"]\n    User([\"\ud83d\udc64 User\"])\n\n    %% === FLOW ===\n\n    %% Events to API\n    telegram -- \"HTTP POST\" --&gt; api\n    webhooks -- \"HTTP POST\" --&gt; api\n\n    %% API to Queue to Executor to Agent\n    api --&gt; queue\n    queue -- \"dequeue by&lt;br/&gt;priority and time\" --&gt; executor\n    executor -- \"spawns fresh&lt;br/&gt;session in Desk/\" --&gt; agent\n\n    %% Agent uses MCPs\n    agent --- pulse_mcp\n    agent --- notify_mcp\n\n    %% MCP feedback\n    pulse_mcp -- \"schedule_pulse()&lt;br/&gt;list/cancel\" --&gt; queue\n    notify_mcp -- \"push alerts\" --&gt; User\n\n    %% Agent &lt;-&gt; Desk\n    DeskRepo -- \"reads context&lt;br/&gt;at startup\" --&gt; agent\n    agent -- \"writes learnings&lt;br/&gt;at end\" --&gt; DeskRepo\n\n    %% User &lt;-&gt; Desk (Glass Box)\n    User &lt;-. \"Glass Box:&lt;br/&gt;read and edit\" .-&gt; DeskRepo\n\n    %% Styles\n    classDef core fill:#4a90a4,stroke:#2e6b7a,color:#fff\n    classDef external fill:#6b9b76,stroke:#4a7a54,color:#fff\n    classDef database fill:#c4955a,stroke:#a67940,color:#fff\n    classDef user fill:#8b6aad,stroke:#6b4a8d,color:#fff\n\n    class api,executor,agent,pulse_mcp,notify_mcp core\n    class telegram,webhooks external\n    class queue,DeskRepo database\n    class User user</code></pre>"},{"location":"#i-the-core-philosophy-the-why","title":"I. The Core Philosophy (The \"Why\")","text":""},{"location":"#1-beyond-the-chatbot-the-push-paradigm","title":"1. Beyond the Chatbot: The \"Push\" Paradigm","text":"<p>The fundamental flaw of modern AI assistants is their passivity. They wait for a prompt. They are tools that sit in a drawer until the user picks them up.</p> <p>Reeve is different. Reeve is built on a \"Push\" Paradigm.</p> <ul> <li>Proactivity First: Reeve does not wait to be asked. It anticipates needs based on time, context, and history. It initiates the conversation.</li> <li>The \"Living\" System: Reeve runs on a continuous loop, a persistent entity that exists even when the user is away. It \"thinks\" while you sleep, organizing your digital life so you wake up to a prepared day.</li> <li>Cognitive Offloading: The ultimate goal is to reduce the user's \"mental RAM\" usage. If the user has to remember to ask the assistant to check something, the assistant has failed.</li> </ul>"},{"location":"#2-the-identity-proxy-gatekeeper","title":"2. The Identity: Proxy &amp; Gatekeeper","text":"<p>Reeve is not just a productivity tool; it is an active layer between the User and the World. It functions as a High-Fidelity Proxy.</p> <ul> <li>The \"Ear\" (Input Filter): The world is noisy. Reeve connects to high-volume channels (WhatsApp, Email, etc.) and filters the signal from the noise. It reads the group chat spam so you don't have to, surfacing only what requires your attention.</li> <li>The \"Mouth\" (Output Delegate): Reeve empowers the user to be in many places at once. It can draft replies, coordinate logistics with friends, or manage vendors, requiring only a simple \"Approved\" from the user to execute.</li> <li>The \"Gatekeeper\": Reeve protects the user's attention. It knows the difference between a \"notification\" (passive info) and an \"interruption\" (urgent action), ensuring the user is never distracted unnecessarily.</li> </ul>"},{"location":"#3-the-persona-the-adaptive-coach","title":"3. The Persona: The Adaptive Coach","text":"<p>Reeve acts as a Productivity Coach and Task Manager, but one that is deeply socially and emotionally aware.</p> <ul> <li>Dynamic Scheduling: Reeve understands that a calendar is not just a grid of slots. It observes the user's tasks completion rates and energy levels. If the user is falling behind, Reeve doesn't nag\u2014it adapts. It might reschedule lower-priority tasks or suggest a break.</li> <li>Emotional Intelligence: Reeve picks up on cues. It knows when to push (\"You promised you'd finish this today\") and when to support (\"You seem overwhelmed; let's push the research task to tomorrow\").</li> <li>The \"Why\" Over the \"What\": Through its understanding of the user's long-term goals, Reeve connects daily drudgery to the bigger picture. It doesn't just remind you to \"exercise\"; it reminds you that you are \"training for the snowboarding season.\"</li> </ul>"},{"location":"#4-transparent-personalization-the-glass-box-principle","title":"4. Transparent Personalization: The \"Glass Box\" Principle","text":"<ul> <li>No Hidden State: Most agents are \"Black Boxes\"\u2014state lives in opaque vector DBs or ephemeral context windows. Reeve is a \"Glass Box.\" Its entire mental state is visible in plain Markdown files on the Desk. If it's acting strange, you can literally open its brain and read it.</li> <li>Write Access to the Brain: Agent stuck in a loop? Don't kill the process. Open the relevant file, delete the bad logic, save. Next wake-up reads the corrected state. You can edit goals, memories, even personality traits\u2014no arguing with a chatbot required.</li> <li>The \"Garden\" You Can Tend (Or Ignore): Through conversation, Reeve proactively tends to this garden\u2014organizing your Goals, tracking your Responsibilities, refining your Preferences. Autopilot works. But you never lose the steering wheel.</li> </ul>"},{"location":"#ii-the-landscape-reeve-vs-openclaw-the-why-this","title":"II. The Landscape: Reeve vs. OpenClaw (The \"Why This?\")","text":"<p>OpenClaw 157k+ stars (formerly Clawdbot/Moltbot) is an outstanding all-in-one runtime implementing the agent loop directly in TypeScript. It has a thriving plugin ecosystem and real-time interaction.</p> <p>Reeve exists because I heard about OpenClaw a couple weeks late, but also represents a fundamentally different architectural bet:</p> OpenClaw Reeve Paradigm Custom runtime Orchestrator wrapping specialized CLIs (Claude Code, Goose) Session Continuous context Isolated per wake-up (research-backed) Memory Markdown files, in-session read/write during continuous execution Git-versioned Desk (Goals/, Diary/, Preferences/), read-at-start/write-at-end Observability Hidden state (debug via logs) Glass Box: inspect &amp; edit the agent's brain in real-time Rollback Filesystem writes (no undo) Git-versioned Desk = \"Undo Button\" for agentic mistakes Extensibility WebSocket Gateway + plugins MCP + HTTP API + Skills, optional C.O.R.E. graph memory Trade-offs Higher token costs (full context), context drift risk Context loss risk (if not captured in Desk), process overhead Best For Real-time OS integration, seamless continuity Scheduled task isolation, cost efficiency, session hygiene <p>Reeve's Core Bet: Let billion-dollar companies compete on agent loops. Focus on orchestration, proactive scheduling, and context hygiene.</p> <p>The Strategic Question: Should Reeve be abandoned, merged, compete, or coexist? See OpenClaw Comparison for detailed analysis and open invitation for feedback.</p>"},{"location":"#iii-use-cases-proxy-coach-gatekeeper-in-action","title":"III. Use Cases: Proxy, Coach, Gatekeeper in Action","text":""},{"location":"#the-snowboarding-trip-social-secretary","title":"The Snowboarding Trip (Social Secretary)","text":"<p>Context: Reeve knows Goal: \"Snowboard 5+ times this season\" + user's friends (\"Shred Crew\"). Trigger: Weather agent detects 18\" forecast at Mammoth. Action: Sends Telegram alert: \"Powder Alert: 18 inches forecast for Mammoth this weekend. Shall I check if the Shred Crew is free?\" Outcome: Upon approval, messages WhatsApp group, parses replies, summarizes headcount, offers to draft Airbnb booking. Zero mental load.</p>"},{"location":"#the-deep-work-defender-gatekeeper","title":"The Deep Work Defender (Gatekeeper)","text":"<p>Context: Calendar filling with 30-min meetings, no coding time. Intervention: Sunday pulse proactively blocks 9 AM-1 PM Monday as \"Deep Work.\" Gatekeeper Logic: - 10:30 AM: Family group chat banter \u2192 Silenced - 11:00 AM: Wife texts \"Emergency, car won't start\" \u2192 Critical, breaks Deep Work lock, pushes alert immediately</p>"},{"location":"#the-adaptive-coach-burnout-prevention","title":"The Adaptive Coach (Burnout Prevention)","text":"<p>Pattern: Missed \"Daily Spanish\" 3 days + curt message replies = burnout risk. Response: \"You've been grinding hard. I've cleared non-essentials for tonight (moved Spanish and Budget Review to weekend). Why not order takeout and disconnect?\" Adaptation: Shifts from Taskmaster \u2192 Supporter, prioritizing mental health over to-do list.</p>"},{"location":"#iv-the-cognitive-mechanics-the-how-it-thinks","title":"IV. The Cognitive Mechanics (The \"How It Thinks\")","text":"<p>Reeve's intelligence is not magic; it is a structured system of transparency, rhythm, and memory.</p>"},{"location":"#1-the-desk-a-collaborative-workspace-the-library","title":"1. The Desk: A Collaborative Workspace (The Library)","text":"<p>At the center of Reeve's mind is \"The Desk\"\u2014a separate Git repository of Markdown files (example desk). This Dual-Repo Architecture is a core design principle: the Engine (<code>reeve-bot/</code>) and your personal context (<code>your-desk/</code>) are completely independent. Your data stays yours\u2014update Reeve without touching your context, roll back mistakes with <code>git revert</code>.</p> <p>The Desk is not just storage; it is a shared whiteboard between the User, Reeve, and its Sub-Agents.</p> <ul> <li>The Folder Structure (hierarchical context, progressive disclosure):</li> <li><code>Goals/</code>: The North Star. Contains <code>Goals.md</code> and other optional markdown files defining additional high-level objectives (e.g., <code>Financial_Freedom.md</code>, <code>Marathon_Training.md</code>).</li> <li><code>Responsibilities/</code>: The Operational Manual. Recurring duties and active projects. Contains <code>Responsibilities.md</code> and optional supporting documents referenced from <code>Responsibilities.md</code> (e.g., <code>Daily_Hygiene.md</code>, <code>Project_Alpha_Specs.md</code>).</li> <li><code>Preferences/</code>: The User Manual. Explicit constraints on communication style, diet, budget, and values. Contains <code>Preferences.md</code> and other optional supporting documents referenced from <code>Preferences.md</code>.</li> <li><code>Diary/</code>: The Stream of Consciousness. Reeve logs its internal monologue here to maintain continuity between wake-up cycles. Reeve must find the best way to organize this and evolve the organization over time.</li> <li> <p><code>.claude/skills/</code>: Workflow automation (7+ specialized skills for morning briefing, pulse scheduling, diary logging, etc.)</p> </li> <li> <p>The \"Blackboard\" Pattern:</p> </li> <li>When Reeve delegates a task (e.g., \"Plan the Japan trip\") to a sub-agent, it doesn't just pass a prompt. It creates a dedicated project folder on the Desk.</li> <li>Sub-agents read from and write to this folder, treating it as a shared blackboard. This allows complex, multi-day tasks to persist without clogging Reeve's immediate context window.</li> </ul>"},{"location":"#2-the-pulse-a-rhythm-of-existence","title":"2. The Pulse: A Rhythm of Existence","text":"<p>Reeve rejects the \"Always On\" model (which breeds distraction) and the \"On Demand\" model (which breeds passivity). Instead, it operates on a Pulse.</p> <ul> <li>Periodic Pulse (The Heartbeat):</li> <li> <p>An hourly cron job wakes Reeve up. It checks the time, reviews the Desk, and asks: \"Does anything need to be done right now?\"</p> </li> <li> <p>Aperiodic Pulse (The Alarm Clock):</p> </li> <li> <p>Reeve can set its own alarms using the <code>schedule_aperiodic_pulse</code> tool. If it needs to check check for flight delays at exactly 6:45 AM sharp and notify the user that they can sleep in a little longer, it sets a wake-up call for that exact moment.</p> </li> <li> <p>The Queue System (Noise Control):</p> </li> <li>Pulse Queue: High-urgency events (Alarms, Critical Emails, messages from the user, wife, etc). These wake Reeve up immediately.</li> <li> <p>Activity Queue: Low-urgency events (Newsletters, server logs). These sit silently. When Reeve next wakes up, it sees a \"Ticker\" (e.g., \"4 new items in Activity Queue\") and decides whether to process them.</p> </li> <li> <p>\"Sticky Notes\" (Self-Prompting):</p> </li> <li>Reeve can leave instructions for its future self. A sticky note like \"Check if the user replied to the snowboarding proposal\" is injected into the prompt of the next Pulse, ensuring follow-through without permanent storage.</li> </ul>"},{"location":"#3-dual-store-memory-the-conscious-vs-subconscious","title":"3. Dual-Store Memory: The Conscious vs. Subconscious","text":"<p>Reeve manages the trade-off between \"Context Window Limits\" and \"Total Recall\" using a two-tiered system.</p> <ul> <li>Tier 1: Working Context (The Desk):</li> <li>Type: Explicit Markdown Files.</li> <li> <p>Role: \"System 2\" Thinking. Slow, deliberate, and organized. This is what Reeve is \"thinking about\" right now. It is editable, transparent, and concise.</p> </li> <li> <p>Tier 2: The Archive (C.O.R.E.):</p> </li> <li>Type: Graph-based persistent memory (via RedPlanetHQ/core).</li> <li>Role: \"System 1\" Association. This is the subconscious. It holds the massive, messy web of history\u2014chat logs, specific entity relationships, and minor details (e.g., \"What restaurant did we go to last November?\").</li> <li>Function: Reeve queries C.O.R.E. only when it needs to retrieve specific details, preventing the Desk from becoming cluttered with trivia.</li> </ul>"},{"location":"#v-the-system-architecture-the-body","title":"V. The System Architecture (The \"Body\")","text":"<p>Reeve is designed to be interface-agnostic. It does not live inside an app; it lives in the terminal, and the world connects to it.</p>"},{"location":"#1-initial-prototype-completed","title":"1. Initial Prototype (Completed)","text":"<p>Status: Operational but Reactive (User-Initiated Only)</p> <p>The current prototype functions as a high-intelligence chatbot but lacks the defining \"Chief of Staff\" agency. It responds to the user but does not yet inhabit the user's life proactively.</p>"},{"location":"#1-the-core-infrastructure-the-hapi-stack","title":"1. The Core Infrastructure (The Hapi Stack)","text":"<ul> <li>The Engine: Claude Code. It serves as the primary reasoning agent, capable of executing terminal commands and managing complex context.</li> <li>The Interface Layer: Hapi (<code>tiann/hapi</code>).</li> <li>Function: Acts as the seamless bridge between local terminal use and remote web access.</li> <li>Session Management: Hapi natively handles session isolation. This allows the user to have distinct, focused conversations (e.g., \"Debug Session,\" \"Trip Planning\") without context bleeding.</li> <li>Notification Gap: While Hapi handles the chat interface, its native notifications are generic. Therefore, the Telegram Notification Tool (detailed in the MVP spec) remains essential for delivering rich, content-aware alerts to the user.</li> </ul>"},{"location":"#2-connected-systems","title":"2. Connected Systems","text":"<ul> <li>Memory: C.O.R.E. is active and connected, providing the \"Archive\" (System 1) memory.</li> <li>Messaging Proxy (WhatsApp): Full integration is complete. Reeve \"masquerades\" as the user, capable of reading group chats and injecting replies back into threads transparently.</li> <li>Email Proxy (Gmail): Full read/write integration is complete. Reeve can triage the inbox, draft replies, and manage threads without the user opening the Gmail client.</li> </ul>"},{"location":"#3-the-proactivity-gap-why-this-is-not-yet-an-mvp","title":"3. The \"Proactivity Gap\" (Why this is not yet an MVP)","text":"<p>While the system is \"smart,\" it fails the \"Push\" paradigm test:</p> <ol> <li>No Pulse: The agent cannot wake itself up. It only acts when the user types in Hapi.</li> <li>No \"Desk\": There is no structured, transparent file system (<code>Goals/</code>, <code>Responsibilities/</code>) for the agent to ground its decisions.</li> <li>Context Amnesia: Without the \"Desk\" or \"Pulse,\" the agent relies entirely on the current session window, losing the \"Big Picture\" view of the user's life.</li> </ol>"},{"location":"#2-the-mvp-specification-in-progress","title":"2. The MVP Specification (In Progress)","text":"<p>Status: Architecture Defined. Implementation Pending.</p> <p>The MVP transforms the current reactive prototype into a functional \"Proactive Chief of Staff.\" The key innovation is moving from a single bot repo to a Dual-Repo Architecture that separates Logic from Context.</p>"},{"location":"#1-the-dual-repo-structure","title":"1. The Dual-Repo Structure","text":"<p>To ensure transparency and modularity, the system is split into two distinct repositories:</p> <ul> <li> <p>A. The Engine: <code>reeve-bot/</code></p> <ul> <li>Role: The immutable logic code.</li> <li>Contents:</li> <li>Implementation of the Pulse Queue (Cron jobs &amp; SQLite/File-based queue).</li> <li>Custom MCP Servers / Tools (Pulse Tools, Telegram Notification Tool).</li> <li>Wrappers to launch Hapi/Claude Code with the correct environment.</li> </ul> </li> <li> <p>B. The Desk: <code>my_reeve/</code></p> <ul> <li>Role: The user's personal context and \"Consciousness.\" This is the Present Working Directory (PWD) when the agent launches.</li> <li>Contents:</li> <li><code>CLAUDE.md</code>: The \"Soul.\" A transparent system prompt explaining: \"You are Reeve. Your goal is X. Your operating mode is Proactive.\"</li> <li><code>SKILLS.md</code>: Explicit definition of available skills (Pulse management, Calendar access).</li> <li><code>Goals/</code>: Directory of Markdown files defining high-level objectives.</li> <li><code>Responsibilities/</code>: Directory of Markdown files defining recurring duties.</li> </ul> </li> </ul>"},{"location":"#2-the-pulse-system-mvp","title":"2. The Pulse System (MVP)","text":"<p>Since Hapi/Claude Code are reactive, <code>reeve-bot</code> introduces an external \"Heartbeat\" mechanism.</p> <ul> <li> <p>The Queue: A unified Pulse Queue managing triggers. Each Pulse consists of:</p> <ul> <li><code>datetime</code>: When to wake up.</li> <li><code>prompt</code>: What to think about (e.g., \"Hourly Check\" vs. \"Check Ticket Prices\").</li> <li><code>session_link</code>: (Optional) Context to resume.</li> </ul> </li> <li> <p>The Mechanic:</p> <ol> <li>The Cron/Scheduler fires.</li> <li>It launches a new Hapi session (preventing context confusion in old threads).</li> <li>Sticky Note Injection: It checks for any \"Sticky Notes\" left by the previous session (e.g., \"Check if the user replied to the ski trip\") and injects them into the new context.</li> <li>It injects the specific <code>prompt</code> + content of <code>CLAUDE.md</code> + <code>Goals/</code> summary.</li> </ol> </li> <li> <p>The Tools (Exposed via <code>.claude/skills/../SKILL.md</code>):</p> <ul> <li><code>schedule_aperiodic_pulse(datetime, prompt) -&gt; PulseId</code>: Allows Reeve to set its own alarm clock for specific future tasks.</li> <li><code>list_upcoming_pulses() -&gt; List[Pulse]</code>: Self-awareness of its future schedule.</li> </ul> </li> </ul>"},{"location":"#3-the-notification-bridge-hapi-telegram","title":"3. The Notification Bridge (Hapi + Telegram)","text":"<ul> <li>The Problem: Hapi's native push notifications are empty (\"New output\").</li> <li>The Solution: A dedicated <code>send_user_notification</code> tool.</li> <li>Reeve bypasses Hapi's native alerts for content.</li> <li>It sends a rich message via Telegram: \"Found a slot for your Deep Work.\"</li> <li>The Deep Link: The message includes a URL to the specific Hapi session, allowing the user to click and immediately jump into the relevant context/chat thread on their device.</li> </ul>"},{"location":"#4-integration-google-calendar","title":"4. Integration: Google Calendar","text":"<ul> <li>Requirement: Full Read/Write MCP Integration.</li> <li>Capabilities:</li> <li>Audit: Read the upcoming week to identify fragments and conflicts.</li> <li>Defense: Write \"Blockers\" for Deep Work without asking.</li> <li>Coordination: Send invites to external contacts.</li> </ul>"},{"location":"#3-the-future-roadmap","title":"3. The Future Roadmap","text":"<ul> <li> <p>Activity Queue Implementation:</p> <ul> <li>Development of a \"Low-Urgency\" parallel queue for passive events (e.g., newsletter summaries, system logs, non-critical updates).</li> <li>Mechanism: Unlike the Pulse Queue, these items do not trigger a wake-up. They are buffered and presented as a summary ticker (e.g., \"3 new log items\") during the next scheduled Periodic Pulse, preventing \"alert fatigue.\"</li> </ul> </li> <li> <p>Recursive Sub-Agents (maybe using claude sub-agents):</p> <ul> <li>Implementation of a robust \"Manager/Worker\" pattern where Reeve spawns ephemeral agent processes for long-running tasks (e.g., \"Monitor this eBay listing for 3 days\").</li> <li>Mechanism: Sub-agents report back via the \"Blackboard\" (Desk files) rather than context stuffing.</li> </ul> </li> <li> <p>Custom notification priorities: The notification tool has an additional priority to control user attention:</p> </li> <li>Silent: Logged to history but triggers no notification (e.g., \"Updated the library,\" \"Sub-agent finished research\").</li> <li>Normal: Standard push notification to Telegram.</li> <li> <p>Critical: High-priority alert that overrides DND settings (via the Wrapper's API privileges).</p> </li> <li> <p>Full \"World\" Proxy (WhatsApp/Email):</p> <ul> <li>Current State: Reeve \"listens\" (via local listeners) and reports to Telegram.</li> <li>Future State: Reeve \"masquerades.\" It will have tools to inject messages back into WhatsApp threads or draft emails directly, allowing the user to reply to a WhatsApp group via Telegram without ever opening the WhatsApp app.</li> </ul> </li> <li> <p>Hardware Independence:</p> <ul> <li>Because the architecture is just a \"Terminal Wrapper,\" Reeve can eventually be ported to voice interfaces, wearables, or custom hardware with zero changes to the core agent logic.</li> </ul> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Clone and install\ngit clone https://github.com/reubenjohn/reeve-bot.git\ncd reeve-bot\nuv sync\n\n# Run migrations\nuv run alembic upgrade head\n\n# Run tests\nuv run pytest tests/ -v\n\n# Start the daemon (requires configuration)\nexport PULSE_API_TOKEN=your-secret-token\nuv run python -m reeve.pulse\n</code></pre> <p>For full installation and configuration details, see the Implementation Roadmap.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see Contributing for detailed guidelines on:</p> <ul> <li>Setting up your development environment</li> <li>Running tests and formatting code</li> <li>Submitting pull requests</li> <li>Reporting issues</li> <li>Understanding the project architecture</li> </ul> <p>Whether you're fixing bugs, adding features, or improving documentation, we appreciate your help in making Reeve better.</p>"},{"location":"#strategic-direction-feedback","title":"Strategic Direction Feedback","text":"<p>Before diving into code contributions, consider reading OpenClaw Comparison for context on Reeve's architectural philosophy and the open strategic questions facing the project. For exploratory concepts still in development, see Ideas &amp; Future. Community feedback on the \"orchestrator vs. runtime\" trade-offs is especially valuable and can be shared in GitHub Discussions.</p>"},{"location":"IDEAS/","title":"Reeve Bot - Future Ideas &amp; Explorations","text":"<p>This document tracks nascent-stage ideas that are still being explored and have not yet made it into the formal roadmap. Think of this as a sandbox for potential features, improvements, and architectural experiments.</p>"},{"location":"IDEAS/#categorization","title":"Categorization","text":"<p>Ideas are loosely categorized by theme. As ideas mature, they will migrate to the Future Roadmap section of the README.</p>"},{"location":"IDEAS/#intelligence-reasoning","title":"\ud83e\udde0 Intelligence &amp; Reasoning","text":""},{"location":"IDEAS/#multi-model-ensemble","title":"Multi-Model Ensemble","text":"<ul> <li>Concept: Use different Claude models for different tasks (Haiku for triage, Sonnet for execution, Opus for strategic planning)</li> <li>Benefits: Cost optimization, speed improvements for routine tasks</li> <li>Questions: How to route tasks? How to maintain coherence across model switches?</li> </ul>"},{"location":"IDEAS/#self-reflection-loop","title":"Self-Reflection Loop","text":"<ul> <li>Concept: Periodic \"meta-sessions\" where Reeve reviews its own diary and identifies patterns in user behavior or its own mistakes</li> <li>Benefits: Continuous improvement without manual feedback loops</li> <li>Questions: How often? What triggers reflection? How to avoid recursive loops?</li> </ul>"},{"location":"IDEAS/#goal-decomposition-engine","title":"Goal Decomposition Engine","text":"<ul> <li>Concept: Automatic breakdown of high-level goals (e.g., \"Get fit for snowboarding season\") into actionable tasks with dependencies</li> <li>Benefits: Reduced user burden in task planning</li> <li>Questions: How to handle ambiguity? How to learn user's decomposition preferences?</li> </ul>"},{"location":"IDEAS/#workflow-automation","title":"\ud83d\udd04 Workflow &amp; Automation","text":""},{"location":"IDEAS/#smart-batching","title":"Smart Batching","text":"<ul> <li>Concept: Group similar low-priority tasks (e.g., \"Reply to 3 non-urgent emails\") and propose batch processing sessions</li> <li>Benefits: Reduce context switching, improve focus</li> <li>Questions: What constitutes \"similar\"? How to detect optimal batch timing?</li> </ul>"},{"location":"IDEAS/#conditional-pulses","title":"Conditional Pulses","text":"<ul> <li>Concept: Pulses that only fire if certain conditions are met (e.g., \"Wake up only if flight price drops below $500\")</li> <li>Benefits: More efficient resource usage, better user experience</li> <li>Questions: Where to store conditions? How to evaluate them efficiently?</li> </ul>"},{"location":"IDEAS/#parallel-task-execution","title":"Parallel Task Execution","text":"<ul> <li>Concept: Allow Reeve to spawn multiple concurrent Hapi sessions for independent tasks</li> <li>Benefits: Faster execution of multi-threaded workflows</li> <li>Questions: Session isolation? Resource limits? How to merge results?</li> </ul>"},{"location":"IDEAS/#integration-connectivity","title":"\ud83d\udcf1 Integration &amp; Connectivity","text":""},{"location":"IDEAS/#voice-interface","title":"Voice Interface","text":"<ul> <li>Concept: Voice-based interaction via local STT/TTS or cloud services</li> <li>Benefits: Hands-free operation, accessibility</li> <li>Questions: Latency requirements? Privacy concerns? Wake word detection?</li> </ul>"},{"location":"IDEAS/#wearable-integration","title":"Wearable Integration","text":"<ul> <li>Concept: Push notifications to smartwatch, biometric data as context (sleep quality, heart rate)</li> <li>Benefits: Better awareness of user state, context-aware scheduling</li> <li>Questions: Which wearables? Data privacy? How to interpret biometric signals?</li> </ul>"},{"location":"IDEAS/#calendar-intelligence-layer","title":"Calendar Intelligence Layer","text":"<ul> <li>Concept: Beyond read/write access\u2014predict meeting overruns, suggest reschedules based on energy patterns</li> <li>Benefits: Smarter time management</li> <li>Questions: How to predict? How to avoid over-optimization?</li> </ul>"},{"location":"IDEAS/#email-auto-responder-templates","title":"Email Auto-Responder Templates","text":"<ul> <li>Concept: Learn user's response patterns and suggest/auto-send replies to common email types</li> <li>Benefits: Reduce inbox burden</li> <li>Questions: When to auto-send vs. draft? How to avoid embarrassing mistakes?</li> </ul>"},{"location":"IDEAS/#privacy-security","title":"\ud83d\udee1\ufe0f Privacy &amp; Security","text":""},{"location":"IDEAS/#local-first-llm-option","title":"Local-First LLM Option","text":"<ul> <li>Concept: Support for running local models (Llama, Mistral) for privacy-sensitive operations</li> <li>Benefits: Complete data sovereignty, offline operation</li> <li>Questions: Performance trade-offs? Which operations require local processing?</li> </ul>"},{"location":"IDEAS/#encrypted-desk","title":"Encrypted Desk","text":"<ul> <li>Concept: Optional encryption of the Desk repository at rest</li> <li>Benefits: Protection of sensitive personal data</li> <li>Questions: Key management? Performance impact? Compatibility with Git?</li> </ul>"},{"location":"IDEAS/#audit-trail","title":"Audit Trail","text":"<ul> <li>Concept: Immutable log of all Reeve actions (messages sent, files edited, API calls)</li> <li>Benefits: Trust, debugging, compliance</li> <li>Questions: Storage requirements? How long to retain? Privacy implications?</li> </ul>"},{"location":"IDEAS/#user-experience","title":"\ud83c\udfa8 User Experience","text":""},{"location":"IDEAS/#natural-language-desk-editing","title":"Natural Language Desk Editing","text":"<ul> <li>Concept: Instead of manually editing markdown, use conversational commands (\"Add 'Learn pottery' to my goals\")</li> <li>Benefits: Lower barrier to entry, more natural interaction</li> <li>Questions: How to preserve user's markdown formatting preferences? Risk of accidental overwrites?</li> </ul>"},{"location":"IDEAS/#visual-dashboard","title":"Visual Dashboard","text":"<ul> <li>Concept: Optional web UI showing Desk structure, pulse schedule, recent actions</li> <li>Benefits: Better overview, easier onboarding</li> <li>Questions: Maintenance burden? Conflicts with \"terminal-first\" philosophy?</li> </ul>"},{"location":"IDEAS/#contextual-interruptions","title":"Contextual Interruptions","text":"<ul> <li>Concept: Instead of binary DND, allow context-aware interruptions (e.g., \"Interrupt only if urgent AND related to current project\")</li> <li>Benefits: Better attention management</li> <li>Questions: How to define context? How to evaluate urgency?</li> </ul>"},{"location":"IDEAS/#experimental","title":"\ud83d\udd2c Experimental","text":""},{"location":"IDEAS/#emotion-detection","title":"Emotion Detection","text":"<ul> <li>Concept: Infer user emotional state from message tone, response latency, word choice</li> <li>Benefits: Better coaching, burnout prevention</li> <li>Questions: Accuracy? Ethical concerns? How to avoid over-interpretation?</li> </ul>"},{"location":"IDEAS/#predictive-pulses","title":"Predictive Pulses","text":"<ul> <li>Concept: Machine learning model to predict when user will need something (e.g., \"Usually checks flight prices on Tuesdays\")</li> <li>Benefits: Anticipatory assistance</li> <li>Questions: Data requirements? How to avoid creepiness? Overfitting to past behavior?</li> </ul>"},{"location":"IDEAS/#collaborative-reeve","title":"Collaborative Reeve","text":"<ul> <li>Concept: Multi-user Reeve instances that can delegate tasks to each other (e.g., user's Reeve coordinates with spouse's Reeve for family scheduling)</li> <li>Benefits: Household coordination</li> <li>Questions: Privacy boundaries? Authentication? Conflict resolution?</li> </ul>"},{"location":"IDEAS/#notes","title":"\ud83d\udcdd Notes","text":"<ul> <li>Ideas listed here are not commitments\u2014they are explorations</li> <li>Some ideas may be abandoned, merged, or significantly revised as understanding evolves</li> <li>Feedback and refinement are welcome as the project matures</li> </ul> <p>Last Updated: 2026-01-24 Status: Living document, updated as new ideas emerge</p>"},{"location":"MCP_SETUP/","title":"MCP Server Setup Guide","text":"<p>This guide explains how to configure the Reeve MCP servers for use with Claude Code.</p>"},{"location":"MCP_SETUP/#prerequisites","title":"Prerequisites","text":"<ol> <li>Claude Code CLI installed and configured</li> <li>Reeve Bot project set up at <code>/home/reuben/workspace/reeve-bot</code></li> <li>Database initialized (run <code>uv run alembic upgrade head</code>)</li> <li>Environment variables configured (see <code>.env.example</code>)</li> </ol>"},{"location":"MCP_SETUP/#step-1-copy-mcp-configuration","title":"Step 1: Copy MCP Configuration","text":"<p>Copy the example MCP configuration to your Claude Code config directory:</p> <pre><code># Create the config directory if it doesn't exist\nmkdir -p ~/.config/claude-code\n\n# Copy the example configuration\ncp mcp_config.json.example ~/.config/claude-code/mcp_config.json\n</code></pre>"},{"location":"MCP_SETUP/#step-2-update-configuration-paths","title":"Step 2: Update Configuration Paths","text":"<p>Edit <code>~/.config/claude-code/mcp_config.json</code> and update the following:</p> <ol> <li>Project path: Replace <code>/home/reuben/workspace/reeve-bot</code> with your actual project path</li> <li>Database path: Replace <code>/home/reuben/.reeve/pulse_queue.db</code> with your database path</li> <li>Telegram credentials: Replace <code>your_bot_token_here</code> and <code>your_chat_id_here</code> with actual values</li> </ol>"},{"location":"MCP_SETUP/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"mcpServers\": {\n    \"pulse-queue\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--directory\",\n        \"/home/your_username/workspace/reeve-bot\",\n        \"python\",\n        \"-m\",\n        \"reeve.mcp.pulse_server\"\n      ],\n      \"env\": {\n        \"PULSE_DB_PATH\": \"/home/your_username/.reeve/pulse_queue.db\"\n      }\n    },\n    \"telegram-notifier\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--directory\",\n        \"/home/your_username/workspace/reeve-bot\",\n        \"python\",\n        \"-m\",\n        \"reeve.mcp.notification_server\"\n      ],\n      \"env\": {\n        \"TELEGRAM_BOT_TOKEN\": \"123456789:ABCdefGHIjklMNOpqrsTUVwxyz\",\n        \"TELEGRAM_CHAT_ID\": \"987654321\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"MCP_SETUP/#step-3-get-telegram-credentials","title":"Step 3: Get Telegram Credentials","text":""},{"location":"MCP_SETUP/#get-bot-token","title":"Get Bot Token","text":"<ol> <li>Open Telegram and message @BotFather</li> <li>Send <code>/newbot</code> and follow the prompts</li> <li>Copy the bot token (format: <code>123456789:ABCdefGHIjklMNOpqrsTUVwxyz</code>)</li> </ol>"},{"location":"MCP_SETUP/#get-chat-id","title":"Get Chat ID","text":"<ol> <li>Start a chat with your bot</li> <li>Send any message to your bot</li> <li>Visit: <code>https://api.telegram.org/bot&lt;YOUR_BOT_TOKEN&gt;/getUpdates</code></li> <li>Find your <code>chat.id</code> in the JSON response (format: <code>987654321</code>)</li> </ol>"},{"location":"MCP_SETUP/#step-4-test-the-configuration","title":"Step 4: Test the Configuration","text":""},{"location":"MCP_SETUP/#test-pulse-queue-server","title":"Test Pulse Queue Server","text":"<p>In a Claude Code session:</p> <pre><code>Can you list my upcoming pulses?\n</code></pre> <p>Claude should call the <code>list_upcoming_pulses</code> MCP tool. If no pulses exist, you'll see:</p> <pre><code>No upcoming pulses scheduled. The schedule is clear.\n</code></pre>"},{"location":"MCP_SETUP/#test-telegram-notifier","title":"Test Telegram Notifier","text":"<p>In a Claude Code session:</p> <pre><code>Can you send me a test notification?\n</code></pre> <p>Claude should call the <code>send_notification</code> MCP tool, and you should receive a Telegram message.</p>"},{"location":"MCP_SETUP/#step-5-verify-mcp-servers-are-loaded","title":"Step 5: Verify MCP Servers Are Loaded","text":"<p>You can verify the servers are loaded by checking Claude Code's startup:</p> <pre><code># Run Claude Code in verbose mode\nclaude-code --verbose\n</code></pre> <p>You should see logs indicating the MCP servers are starting.</p>"},{"location":"MCP_SETUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"MCP_SETUP/#server-not-found","title":"Server Not Found","text":"<p>Error: <code>MCP server 'pulse-queue' not found</code></p> <p>Solution: Check that the configuration file exists at <code>~/.config/claude-code/mcp_config.json</code></p>"},{"location":"MCP_SETUP/#permission-denied","title":"Permission Denied","text":"<p>Error: <code>Permission denied: /home/reuben/workspace/reeve-bot</code></p> <p>Solution: Update the <code>--directory</code> path in the MCP config to your actual project path</p>"},{"location":"MCP_SETUP/#import-error","title":"Import Error","text":"<p>Error: <code>ModuleNotFoundError: No module named 'reeve'</code></p> <p>Solution: Ensure you're using <code>uv run</code> (which activates the virtual environment automatically)</p>"},{"location":"MCP_SETUP/#database-error","title":"Database Error","text":"<p>Error: <code>no such table: pulses</code></p> <p>Solution: Run Alembic migrations:</p> <pre><code>cd /home/reuben/workspace/reeve-bot\nuv run alembic upgrade head\n</code></pre>"},{"location":"MCP_SETUP/#telegram-error","title":"Telegram Error","text":"<p>Error: <code>TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID environment variables are required</code></p> <p>Solution: Add the environment variables to the MCP config's <code>env</code> section</p>"},{"location":"MCP_SETUP/#manual-testing-without-claude-code","title":"Manual Testing (Without Claude Code)","text":"<p>You can test the MCP servers manually using stdio:</p>"},{"location":"MCP_SETUP/#test-pulse-queue-server_1","title":"Test Pulse Queue Server","text":"<pre><code>cd /home/reuben/workspace/reeve-bot\nuv run python -m reeve.mcp.pulse_server\n</code></pre> <p>The server will start and wait for JSON-RPC input on stdin.</p>"},{"location":"MCP_SETUP/#test-telegram-notifier_1","title":"Test Telegram Notifier","text":"<pre><code>export TELEGRAM_BOT_TOKEN=\"your_token\"\nexport TELEGRAM_CHAT_ID=\"your_chat_id\"\ncd /home/reuben/workspace/reeve-bot\nuv run python -m reeve.mcp.notification_server\n</code></pre>"},{"location":"MCP_SETUP/#security-notes","title":"Security Notes","text":"<ol> <li>Bot Token: Keep your Telegram bot token secret. Don't commit it to git.</li> <li>Chat ID: Your chat ID is less sensitive but should still be kept private.</li> <li>MCP Config: The <code>~/.config/claude-code/mcp_config.json</code> file is user-specific and not in git.</li> </ol>"},{"location":"MCP_SETUP/#next-steps","title":"Next Steps","text":"<p>Once MCP servers are working:</p> <ol> <li>Schedule your first pulse: Ask Claude to schedule a test pulse</li> <li>Set up the daemon: See architecture/daemon-api.md</li> <li>Deploy to production: See architecture/deployment.md</li> </ol>"},{"location":"MCP_SETUP/#available-mcp-tools","title":"Available MCP Tools","text":""},{"location":"MCP_SETUP/#pulse-queue-tools","title":"Pulse Queue Tools","text":"<ul> <li><code>schedule_pulse(scheduled_at, prompt, priority, ...)</code> - Schedule a new pulse</li> <li><code>list_upcoming_pulses(limit, include_completed)</code> - List scheduled pulses</li> <li><code>cancel_pulse(pulse_id)</code> - Cancel a pulse</li> <li><code>reschedule_pulse(pulse_id, new_scheduled_at)</code> - Reschedule a pulse</li> </ul>"},{"location":"MCP_SETUP/#telegram-notifier-tools","title":"Telegram Notifier Tools","text":"<ul> <li><code>send_notification(message, priority, parse_mode)</code> - Send a push notification with auto-generated session link</li> </ul> <p>The notification tool automatically includes a \"View in Claude Code\" button that links back to the current session, so the user can quickly return to the conversation.</p> <p>See the MCP server source code for complete documentation on each tool.</p>"},{"location":"OpenClaw_COMPARISON/","title":"Reeve vs. OpenClaw: Architectural Comparison &amp; Strategic Decision","text":"<p>Status: Open Question | Last Updated: 2026-02-15</p> <p>Fact-Check Note: This document was originally written 2026-01-29. It has been substantially revised based on a detailed codebase fact-check (OpenClaw commit <code>0cf93b8fa</code>, 2026-02-09) that found several original claims to be inaccurate. Corrections are noted inline. The overall framing has shifted from \"opaque vs. transparent\" to a more honest comparison of architectural philosophies.</p>"},{"location":"OpenClaw_COMPARISON/#executive-summary","title":"Executive Summary","text":"<p>OpenClaw is the dominant open-source personal AI assistant (174k+ GitHub stars, 455+ contributors). This document provides a technical comparison between OpenClaw and Reeve, and frames the strategic question:</p> <p>Should Reeve be abandoned, merged with OpenClaw, compete directly, or coexist as a complementary approach?</p> <p>Both systems share more architectural DNA than originally understood \u2014 plain Markdown memory, configurable session isolation, scheduled proactivity. The genuine differences lie in session philosophy (continuity vs. isolation as default), conversation-level meta-skills (retrospection, self-testing, self-improvement), and the Desk as an opinionated thinking framework vs. a general-purpose workspace.</p>"},{"location":"OpenClaw_COMPARISON/#the-fundamental-difference-runtime-vs-orchestrator","title":"The Fundamental Difference: Runtime vs. Orchestrator","text":""},{"location":"OpenClaw_COMPARISON/#openclaw-the-all-in-one-runtime","title":"OpenClaw: The All-in-One Runtime","text":"<p>Architecture: OpenClaw is a custom agent runtime built in TypeScript/Node.js. It directly implements the agent loop \u2014 the core \"Thought \u2192 Tool \u2192 Observation\" cycle that powers agentic AI.</p> <p>Philosophy: Integration over modularity. OpenClaw is a complete system where the agent loop, memory management, tool execution, and communication protocols are tightly coupled in a single codebase.</p> <p>Key Components: - Custom WebSocket \"Gateway\" serving as the central nervous system - Native tool/skill execution engine - Plain Markdown memory (<code>MEMORY.md</code>, <code>memory/YYYY-MM-DD.md</code>) with hybrid search (BM25 + vector embeddings) - Multiple session types with configurable isolation (<code>dmScope</code>: <code>main</code>, <code>per-peer</code>, <code>per-channel-peer</code>) - Multi-platform integrations (Telegram, Discord, WhatsApp, iMessage \u2014 7+ channels) - 5 proactive mechanisms: Heartbeat, Cron, Hooks, Webhooks, Agent-to-Agent - ClawHub marketplace (31,000+ skills) + 52+ bundled skills - OpenProse declarative workflow engine for <code>.prose</code> programs - Web dashboard and Terminal UI (TUI)</p> <p>Strengths: - Batteries-included experience with massive ecosystem - 174k+ stars, active community, rapid development - Unified architecture where everything \"just works\" - Real-time streaming of tool outputs via WebSockets - Multiple scheduling mechanisms with fine-grained control - OpenProse enables code-level self-improvement for <code>.prose</code> workflows</p> <p>Trade-offs: - High coupling to the custom implementation - Breaking changes during rapid development phase - Must maintain compatibility with evolving LLM APIs - Context management within sessions relies on compaction/summarization</p>"},{"location":"OpenClaw_COMPARISON/#reeve-the-specialized-orchestrator","title":"Reeve: The Specialized Orchestrator","text":"<p>Architecture: Reeve is a supervisor process that orchestrates specialized agentic IDEs (Claude Code, GitHub Copilot, Goose, Cursor) rather than reimplementing the agent loop.</p> <p>Philosophy: Specialization over integration. Bet on billion-dollar companies (Anthropic, GitHub, Microsoft) to build the best agent loops, focus on what they're NOT building \u2014 proactive scheduling, context management, and conversation-level self-improvement.</p> <p>Key Components: - Pulse Queue (Python/SQLite): Core scheduling system for wake-up events - Executor: Launches fresh agent sessions with explicit context injection - Desk: An opinionated thinking framework (reeve_desk) with structured folders for Goals, Responsibilities, Preferences, and Diary \u2014 each with distinct update cadences - Session Hygiene: Treats each wake-up as a new, isolated session by default - Meta-Skills: Conversation-level retrospection (nightly pattern analysis), self-testing (git worktree fork-test-merge), and source code self-awareness - MCP servers for self-scheduling and notifications - HTTP API for external event triggers - Lightweight integrations (Telegram listener)</p> <p>Strengths: - Decoupling from implementation churn: Anthropic/GitHub teams optimize the agent loop while Reeve focuses on orchestration - Session isolation by default: Fresh context per task prevents hallucination accumulation - Conversation-level self-improvement: Nightly retrospection analyzes conversations for patterns, mistakes, and behavioral updates \u2014 a feedback loop not present in OpenClaw - Self-testing with rollback: Behavior changes validated via git worktree isolation before being merged - Opinionated personalization: Desk framework bootstraps a highly personalized assistant out of the box - Research-backed design: Informed by agentic IDE analysis - Model flexibility: Desk can be optimized per-model (Claude, GPT-4, Gemini) without touching orchestration logic</p> <p>Trade-offs: - Depends on external CLIs remaining stable and accessible - No plugin ecosystem or marketplace (starting from zero) - Higher per-wake-up latency (process spawning overhead) - Solo developer vs. large community (for now) - Risk of context loss if information not captured in Desk between sessions</p>"},{"location":"OpenClaw_COMPARISON/#technical-deep-dive","title":"Technical Deep Dive","text":""},{"location":"OpenClaw_COMPARISON/#1-the-gateway-vs-the-pulse-queue","title":"1. The \"Gateway\" vs. The \"Pulse Queue\"","text":""},{"location":"OpenClaw_COMPARISON/#openclaws-gateway","title":"OpenClaw's Gateway","text":"<p>A local WebSocket server (port 18789) that serves as the event hub: - Different adapters (Telegram, Discord, CLI) connect as WebSocket clients - Agent awakened by scheduled heartbeats (~30min default) and cron jobs - Proactivity via integrated subsystems: Cron (precise scheduling with 5-field expressions) + Heartbeat (periodic awareness) + Hooks + Webhooks + Agent-to-Agent - Multiple session types: main, per-peer, per-channel-peer, isolated cron sessions - Context is continuous within a session, managed by compaction + daily resets</p> <p>Code Evidence: <code>src/gateway/server-cron.ts</code>, <code>src/cron/service.ts</code>, <code>src/infra/heartbeat-wake.ts</code></p> <p>Use Case: You send a Telegram message. The adapter emits a WebSocket event, the agent immediately \"hears\" it and responds. Efficient and real-time. For proactive tasks, the cron timer polls for due jobs and can spawn isolated sessions (<code>sessionKey: \"cron:&lt;jobId&gt;\"</code>).</p>"},{"location":"OpenClaw_COMPARISON/#reeves-pulse-queue","title":"Reeve's Pulse Queue","text":"<p>A SQLite-backed scheduler with priority-based execution: - Periodic pulses (hourly heartbeat) and aperiodic pulses (self-scheduled alarms) - Each pulse spawns a fresh agent session with explicit context - \"Sticky Notes\" carry forward essential context between sessions - Failed pulses retry with exponential backoff</p> <p>Use Case: At 6:45 AM, a pulse fires to check flight status. A new Claude Code session starts with the prompt \"Check flight UA123 for delays\" + sticky note \"User departs at 8:00 AM\". Session completes, process exits. Clean slate for next pulse.</p>"},{"location":"OpenClaw_COMPARISON/#2-memory-learning-architecture","title":"2. Memory &amp; Learning Architecture","text":"<p>Both systems use plain Markdown files for persistent memory. The difference is in session integration, structure, and what the memory is designed for.</p>"},{"location":"OpenClaw_COMPARISON/#openclaw","title":"OpenClaw","text":"<ul> <li>Plain Markdown memory: <code>MEMORY.md</code> (curated long-term), <code>memory/YYYY-MM-DD.md</code> (daily logs)</li> <li>Hybrid search: BM25 (FTS5) + vector similarity with weighted scoring for retrieval</li> <li>Agent maintains continuous context within session, reading/writing files during long-running session</li> <li>Pre-compaction flush: Summarizes before context window fills, extracting key info to durable files</li> <li>Session resets: <code>/new</code> command, daily reset (default 4:00 AM), idle expiry</li> <li>Agent-centric workspace bootstrap: <code>AGENTS.md</code>, <code>SOUL.md</code>, <code>USER.md</code>, <code>IDENTITY.md</code>, <code>TOOLS.md</code> \u2014 defining what the agent is</li> <li>Git repo auto-initialized for workspace, but no automatic commits</li> </ul> <p>Strength: Continuous learning within sessions, sophisticated retrieval (hybrid search), immediate context accumulation Design Challenge: Context drift within long sessions (mitigated via compaction), compaction can lose nuanced details</p>"},{"location":"OpenClaw_COMPARISON/#reeve-with-reeve_desk","title":"Reeve (with reeve_desk)","text":"<ul> <li>Separate Git repository holding user context (example)</li> <li>Agent reads files at session start, writes updates before session exit</li> <li>User-centric structured folders with distinct update cadences:</li> <li><code>Goals/</code>: Long-term objectives with success criteria (updated weekly/monthly)</li> <li><code>Responsibilities/</code>: Recurring duties with cadences \u2014 daily, weekly, monthly (updated as duties change)</li> <li><code>Preferences/</code>: User constraints and communication rules (updated when preferences evolve)</li> <li><code>Diary/</code>: Activity logs, pattern tracking, temporal context (updated every session)</li> <li><code>Diary/Patterns/</code>: Emergent patterns, created when data appears 3+ days in a row</li> <li><code>.claude/skills/</code>: 14 specialized skills including 3 meta-skills (retrospection, self-testing, session analysis)</li> <li>Template model: Public template (reeve_desk_template) that users fork and personalize. ~60% template structure, ~40% organic growth.</li> <li>Context engineering as first-class skill: Decision tree and size guidelines for what goes where. \"You are ephemeral. The Desk is eternal.\"</li> <li>Self-organization discipline: Mandatory checklist per pulse (context capture, desk hygiene, anticipation, learning)</li> <li>Automatic git commits with diff notifications: Every Desk modification is committed and the user is texted a link to the diff</li> </ul> <p>Strength: Git-versioned knowledge evolution, session isolation prevents hallucination bleed, cost efficiency (only loads needed context per session), opinionated structure bootstraps personalization out of the box</p> <p>Design Challenge: Process spawning overhead (mitigated via priority-based scheduling), risk of context loss if information not captured in Desk between sessions (user may need to repeat information), requires discipline in maintaining Desk files</p>"},{"location":"OpenClaw_COMPARISON/#whats-equivalent-whats-different","title":"What's Equivalent, What's Different","text":"Dimension OpenClaw Reeve Storage format Plain Markdown Plain Markdown Inspectability Fully transparent Fully transparent Git support Auto-initialized, manual commits Auto-commits + diff notifications Bootstrap philosophy Agent-centric (\"what is the agent?\") User-centric (\"what does the user need?\") Structure General-purpose workspace Opinionated thinking framework Template/sharing Portable workspaces Fork-and-personalize template model Retrieval Hybrid search (BM25 + vector) File-based progressive disclosure"},{"location":"OpenClaw_COMPARISON/#3-the-costcontext-trade-off","title":"3. The Cost/Context Trade-Off","text":"<p>The session model choice has direct implications on operational costs and user experience:</p>"},{"location":"OpenClaw_COMPARISON/#openclaws-continuous-context-approach","title":"OpenClaw's Continuous Context Approach","text":"<p>Advantages: - No repetition needed: Context accumulates naturally within session - Low latency: No process spawning overhead per interaction - Implicit learning: Agent picks up patterns without explicit memory writes</p> <p>Costs: - Higher token usage: Full context sent with each API call - Context window pressure: Requires pre-compaction flush mechanisms - Compaction risks: Summarization can lose nuanced details</p> <p>Example: After discussing project preferences once, agent remembers them for the entire session (hours/days). But session accumulates 50k+ tokens, requiring periodic summarization.</p>"},{"location":"OpenClaw_COMPARISON/#reeves-session-isolation-approach","title":"Reeve's Session Isolation Approach","text":"<p>Advantages: - Cost efficiency: Only loads relevant Desk files per pulse (~2-5k tokens) - No context drift: Each session starts clean - Explicit knowledge: All learning visible in git diffs</p> <p>Costs: - Context loss risk: If information not captured in Desk, user must repeat - Process overhead: Fresh Hapi session spawn per pulse (~1-3s latency) - Manual curation: Requires discipline in updating Desk files</p> <p>Example: Morning briefing pulse reads Goals.md + today's Responsibilities.md (~3k tokens). If user mentioned preference yesterday but it wasn't written to Preferences.md, they'll need to repeat it.</p> <p>The Fundamental Trade-Off: - OpenClaw: Pays in tokens/compaction for seamless continuity - Reeve: Pays in latency/discipline for cost efficiency and session hygiene</p> <p>Note: OpenClaw also supports isolated sessions (cron with <code>session: isolated</code>, <code>/new</code> command, daily resets). The difference is default philosophy: OpenClaw defaults to session continuity; Reeve defaults to session isolation.</p>"},{"location":"OpenClaw_COMPARISON/#4-conversation-level-meta-skills","title":"4. Conversation-Level Meta-Skills","text":"<p>This is the core differentiator confirmed by codebase fact-checking. OpenClaw's OpenProse provides sophisticated self-improvement for <code>.prose</code> program execution \u2014 but NOT for agent-user conversations. These are different domains.</p>"},{"location":"OpenClaw_COMPARISON/#reeves-meta-skill-feedback-loop","title":"Reeve's Meta-Skill Feedback Loop","text":"<ol> <li> <p>Daily Retrospection \u2014 Every night, Reeve analyzes its diary entries (conversations, decisions, user feedback) looking for patterns, not just summaries. It identifies recurring mistakes, missed opportunities, and behavioral adjustments. Updates its own behavior accordingly.</p> </li> <li> <p>Self-Testing \u2014 When Reeve modifies its own behavior (e.g., updating CLAUDE.md or skill definitions), it forks an isolated copy of the Desk via git worktree, runs simulated scenarios against the modified behavior, and compares results. If any test fails, it rolls back and re-iterates. Only validated changes are merged.</p> </li> <li> <p>Source Code Self-Awareness \u2014 Reeve reads its own source code, skill definitions, and configuration. 443 lines of CLAUDE.md defining identity, architecture, limitations, decision-making frameworks, and runtime behavior. It knows its own retry policies, context window limits, and scheduling implementation.</p> </li> </ol>"},{"location":"OpenClaw_COMPARISON/#what-openclaw-has-instead","title":"What OpenClaw Has Instead","text":"<ul> <li>OpenProse retrospection (<code>49-prose-run-retrospective.prose</code>): Analyzes <code>.prose</code> program execution traces \u2014 different domain than conversations</li> <li>OpenProse simulation (<code>39-architect-by-simulation.prose</code>): Tests <code>.prose</code> program specifications \u2014 not conversation behavior</li> <li>OpenProse inspection (<code>lib/inspector.prose</code>): Inspects <code>.prose</code> code quality \u2014 not agent personality</li> <li>Session transcripts stored as JSONL \u2014 available for analysis, but no automatic nightly processing</li> <li><code>session-memory</code> hook saves summaries when user types <code>/new</code> \u2014 but no pattern extraction</li> <li>Agents can read configuration files (AGENTS.md, SOUL.md) at bootstrap and have the <code>read</code> tool for any file \u2014 but are NOT explicitly guided to read their own source code</li> </ul>"},{"location":"OpenClaw_COMPARISON/#why-this-matters","title":"Why This Matters","text":"<p>This is the meta-skill feedback loop: the agent improves its own conversation behavior over time. OpenClaw improves its code workflows (via OpenProse); Reeve improves its human interaction. These are complementary capabilities, not competing ones.</p> <p>Implementation gap assessment: ~3 weeks of work for OpenClaw to achieve parity on conversation-level meta-skills (retrospection analyzer: 3-4 days, scheduled cron integration: 2-3 days, workspace editor with git safety: 3-4 days, test harness: 3-4 days).</p>"},{"location":"OpenClaw_COMPARISON/#5-the-wrapper-bet","title":"5. The \"Wrapper\" Bet","text":"<p>OpenClaw's Approach: \"We are the runtime. We'll stay competitive with LLM providers.\" - Requires ongoing maintenance as APIs evolve - Community-driven improvements to tool execution - Full control over agent behavior</p> <p>Reeve's Approach: \"Let the billion-dollar companies fight over agent loop optimization. We'll orchestrate.\" - Delegates complex reasoning to an agentic IDE (Claude Code, Goose, Cursor, etc.) - Assumes the underlying CLI will remain competitive and accessible - Risk: If the chosen CLI is deprecated or restricted, Reeve needs a new engine</p> <p>Terms of Service Note: Programmatically invoking Claude Code or VS Code's agentic features may raise ToS concerns. Reeve is engine-agnostic \u2014 open-source alternatives like Goose (Apache 2.0, by Block) or Aider work as drop-in replacements with no restrictions. Just set <code>HAPI_COMMAND=goose</code> to swap engines.</p>"},{"location":"OpenClaw_COMPARISON/#6-extensibility-integration","title":"6. Extensibility &amp; Integration","text":""},{"location":"OpenClaw_COMPARISON/#openclaw_1","title":"OpenClaw","text":"<ul> <li>WebSocket Gateway architecture: Plugins connect to central hub</li> <li>ClawHub marketplace: 31,000+ community skills</li> <li>52+ bundled skills covering common workflows</li> <li>7 plugin types: Channel, Provider, Tool, Service, Skill, Hook, CLI</li> <li>MCP access via mcporter skill (not native, but functional)</li> <li>Integration model: Tight coupling with runtime, real-time streaming, in-process TypeScript execution</li> </ul> <p>Strength: Massive ecosystem, batteries-included, community contributions Challenge: Plugins must adapt to runtime API changes during rapid development</p>"},{"location":"OpenClaw_COMPARISON/#reeve","title":"Reeve","text":"<ul> <li>Three-layer extension model:</li> <li>MCP Servers - Direct tool integration (pulse scheduling, notifications, calendar, etc.)</li> <li>HTTP REST API - External event triggers (any system can POST to <code>/api/pulse/schedule</code>)</li> <li>Integration Listeners - Modular connectors (Telegram, email, etc.) as separate processes</li> <li>Native MCP support: Accesses ~7,000+ MCP tool implementations on GitHub (same ecosystem OpenClaw accesses via mcporter)</li> <li>Protocol-based: Standard HTTP, MCP, asyncio patterns</li> <li>Process isolation: Listener crashes don't affect daemon</li> </ul> <p>Strength: Modular, no vendor lock-in, standard protocols, native MCP integration Challenge: No marketplace, no community plugins (ecosystem starting from scratch)</p> <p>Note: Both systems access the same MCP ecosystem (~7,000+ tools on GitHub). OpenClaw additionally has ClawHub (31,000+ skills). There is no \"Reeve marketplace.\"</p> <p>Example Integration: <pre><code># Adding a Slack listener (independent process)\nclass SlackListener:\n    async def start(self):\n        while True:\n            events = await self.slack_client.poll()\n            for event in events:\n                await self.api.schedule_pulse(\n                    prompt=f\"Slack message: {event.text}\",\n                    priority=\"high\",\n                    source=\"slack\"\n                )\n</code></pre></p>"},{"location":"OpenClaw_COMPARISON/#verified-advantages","title":"Verified Advantages","text":""},{"location":"OpenClaw_COMPARISON/#genuine-reeve-advantages-confirmed-by-fact-check","title":"Genuine Reeve Advantages (Confirmed by Fact-Check)","text":"<p>These differentiators were verified against the OpenClaw codebase and confirmed as genuine gaps:</p> Advantage Detail OpenClaw Status Git auto-commit + diff notifications Every Desk modification is committed; user texted a link to the diff Git repo auto-initialized but no auto-commit or notification Conversation-level retrospection Nightly pattern analysis of conversations, mistakes, and behavioral updates OpenProse analyzes <code>.prose</code> programs, not conversations Conversation-level self-testing Git worktree fork-test-merge for behavior changes OpenProse tests <code>.prose</code> specs, not conversation behavior Source code self-awareness 443-line CLAUDE.md explicitly guides agent to read own source, architecture, and limitations Agents can read files but are not guided to own source code Opinionated Desk framework User-centric structure (Goals/Responsibilities/Preferences/Diary) with template model, update cadences, and self-organization discipline General-purpose workspace with agent-centric bootstrap files"},{"location":"OpenClaw_COMPARISON/#genuine-openclaw-advantages-acknowledged","title":"Genuine OpenClaw Advantages (Acknowledged)","text":"<p>Honest recognition of where OpenClaw excels:</p> Advantage Detail Reeve Status ClawHub marketplace 31,000+ community skills No marketplace Proactive mechanisms 5 types: Heartbeat, Cron, Hooks, Webhooks, Agent-to-Agent 1 type: Pulse OpenProse Declarative workflow engine for code-level self-improvement of <code>.prose</code> programs No equivalent Bundled skills 52+ bundled skills 14 skills Plugin architecture 7 plugin types with in-process TypeScript execution MCP servers (out-of-process) Community &amp; momentum 174k+ stars, 455+ contributors, active development Solo developer Multi-channel real-time 7+ channel adapters with real-time WebSocket streaming Telegram listener only"},{"location":"OpenClaw_COMPARISON/#safety-via-session-isolation","title":"Safety via Session Isolation","text":""},{"location":"OpenClaw_COMPARISON/#session-hygiene","title":"Session Hygiene","text":"<p>Both systems support session isolation, but with different defaults: - OpenClaw defaults to session continuity (with compaction, daily resets, and <code>/new</code> for fresh starts) - Reeve defaults to session isolation (each pulse starts clean, Desk carries forward state)</p> <p>The practical impact of isolation-by-default:</p> <p>Doom Loop Prevention: Continuous-context agents can get stuck in \"doom loops\" \u2014 repeating the same bad error because the failed attempt pollutes the context. Reeve's session isolation means each wake-up starts clean. A bad pulse dies; the next pulse doesn't inherit its mistakes.</p> <p>Drift Detection: By forcing the agent to reconcile actions against a static <code>Responsibilities.md</code> every cycle, Reeve acts as a self-correcting system \u2014 reducing the hallucination drift seen in ungrounded agents.</p> <p>Hot-Swapping the Brain: Agent stuck in a loop? Don't kill the process. Open <code>Diary/current_task.md</code>, delete the bad logic, save. Next pulse reads the corrected state and proceeds.</p>"},{"location":"OpenClaw_COMPARISON/#git-as-undo-button","title":"Git as \"Undo Button\"","text":"<p>The Desk is a Git repository with automatic commits. This provides transaction rollback for agentic mistakes:</p> <ul> <li>Agent deletes something important? <code>git checkout</code> to restore it.</li> <li>Agent rewrites your Goals incorrectly? <code>git diff</code> shows exactly what changed, <code>git revert</code> to undo.</li> <li>Want to audit what the agent did last week? Full history available.</li> <li>Every modification triggers a diff notification to the user \u2014 you always know what changed and why.</li> </ul> <p>Note: OpenClaw also auto-initializes a git repo for its workspace, but does not automatically commit changes or notify the user. Users must manually run <code>git add</code> and <code>git commit</code>. This is a genuine gap \u2014 approximately 1-2 days of implementation effort.</p>"},{"location":"OpenClaw_COMPARISON/#research-foundation","title":"Research Foundation","text":"<p>Reeve's architecture is informed by systematic research documented in agentic-ide-power-user, which analyzes context engineering, grounding, and human-machine interaction patterns across major agentic IDEs (Claude Code, Cursor, GitHub Copilot).</p>"},{"location":"OpenClaw_COMPARISON/#key-research-findings-applied-to-reeve","title":"Key Research Findings Applied to Reeve","text":"<ol> <li>Context Rot Prevention: Performance degrades at 100k+ tokens (Burke Holland SNR Equation, Liu et al., TACL 2024 \u2014 10-25pp accuracy drop for mid-context info)</li> <li> <p>Both systems address this: OpenClaw via compaction/memory flush; Reeve via fresh sessions per pulse</p> </li> <li> <p>Session Hygiene Best Practice: Research-Plan-Implement loop with context resets</p> </li> <li> <p>Reeve's Solution: Each pulse = one phase, results written to Desk, next pulse reads artifacts</p> </li> <li> <p>Progressive Disclosure: Hierarchical information density prevents tool/instruction bloat</p> </li> <li> <p>Both systems implement this: OpenClaw via skill listing + on-demand SKILL.md reads; Reeve via Desk structure (CLAUDE.md \u2192 Goals/ \u2192 Skills/)</p> </li> <li> <p>MCP Tool Overhead: Each tool description costs 100-200 tokens, unconditionally injected</p> </li> <li> <p>Reeve's Solution: Minimal MCP surface (4 pulse tools + notification), Skills for workflows</p> </li> <li> <p>Grounding Mechanisms: Deterministic validation (tests, linters, hooks) prevents hallucinations</p> </li> <li>Reeve's Solution: Executor can invoke arbitrary validation, Desk git history provides auditability</li> </ol> <p>See research summary for full analysis.</p>"},{"location":"OpenClaw_COMPARISON/#code-based-validation","title":"Code-Based Validation","text":"<p>Claims in this document have been validated against the OpenClaw codebase in two rounds: - Initial review: Commit <code>4583f8862</code> (2026-01-29) - Fact-check update: Commit <code>0cf93b8fa</code> (2026-02-09) \u2014 full report in <code>openclaw/findings/FINAL_REPORT.md</code></p>"},{"location":"OpenClaw_COMPARISON/#validated-claims-held-up","title":"Validated Claims (Held Up)","text":"Claim Evidence Custom agent runtime <code>src/agents/pi-embedded-runner/run.ts</code> (470+ lines) \u2014 hand-written loop with retry logic, profile failover WebSocket Gateway hub <code>src/gateway/server.impl.ts</code>, <code>ws-connection.ts</code> \u2014 100+ RPC methods, broadcast coordination Markdown + hybrid storage <code>src/memory/internal.ts</code>, <code>memory-schema.ts</code> \u2014 <code>.md</code> files indexed in SQLite with FTS5 + vector embeddings Pre-compaction memory flush <code>src/auto-reply/reply/memory-flush.ts</code> \u2014 triggers at (contextWindow - reserve - 4000) tokens Plugin ecosystem <code>src/plugins/registry.ts</code>, <code>channels/plugins/</code> \u2014 comprehensive adapter system, 7+ built-in channels Proactivity: Cron + Heartbeat <code>src/cron/service.ts</code>, <code>src/infra/heartbeat-wake.ts</code> \u2014 core subsystems (NOT plugins) Runtime vs. Orchestrator framing Architectural fact: OpenClaw implements agent loop; Reeve delegates to external CLIs"},{"location":"OpenClaw_COMPARISON/#corrected-claims-from-fact-check","title":"Corrected Claims (From Fact-Check)","text":"Original Claim Correction Evidence \"One long-running conversation\" OpenClaw has multiple separate sessions configurable via <code>dmScope</code> (<code>main</code>, <code>per-peer</code>, <code>per-channel-peer</code>). Cron jobs can run in isolated sessions. <code>src/routing/session-key.ts</code>, <code>docs/concepts/session.md</code> \"Hidden/opaque memory\" OpenClaw memory is plain Markdown (<code>MEMORY.md</code>, <code>memory/YYYY-MM-DD.md</code>), fully inspectable <code>docs/concepts/memory.md</code> lines 9-27 \"Unbounded context accumulation\" OpenClaw has auto-compaction, daily session resets, idle expiry, and <code>/new</code> for fresh starts <code>docs/reference/session-management-compaction.md</code> lines 89-92 \"Isolated sessions unique to Reeve\" OpenClaw supports isolated sessions via cron (<code>session: isolated</code>), <code>sessions_spawn</code> tool, and session scoping <code>src/agents/tools/cron-tool.ts</code> \"Desk pattern unique to Reeve\" OpenClaw workspace (<code>~/.openclaw/workspace</code>) is storage-equivalent (both plain Markdown). The distinction is in structure and philosophy, not transparency. <code>src/agents/workspace.ts</code>, <code>docs/concepts/agent-workspace.md</code> \"Pulses unique to Reeve\" OpenClaw has 5 scheduling mechanisms: Heartbeat, Cron, Hooks, Webhooks, Agent-to-Agent <code>src/cron/service.ts</code>, <code>src/infra/heartbeat-wake.ts</code> \"Summarization is a workaround\" Compaction and memory flush are first-class architectural components, not bolted-on fixes <code>agents.defaults.compaction.*</code> configuration, integrated into session lifecycle"},{"location":"OpenClaw_COMPARISON/#confirmed-reeve-advantages-new-findings","title":"Confirmed Reeve Advantages (New Findings)","text":"Advantage Verification Conversation-level retrospection OpenProse's <code>49-prose-run-retrospective.prose</code> analyzes <code>.prose</code> programs, NOT conversations. No conversation analysis exists. Conversation-level self-testing OpenProse's <code>39-architect-by-simulation.prose</code> tests <code>.prose</code> specs, NOT conversation behavior. No conversation testing exists. Git auto-commit + notifications <code>src/infra/git-commit.ts</code> only reads HEAD hash for version info. No auto-commit or notification pipeline. Source code self-awareness Agents can read files via <code>read</code> tool but are not explicitly guided to own source. <code>src/agents/system-prompt.ts</code> does not reference source code location."},{"location":"OpenClaw_COMPARISON/#key-implementation-details","title":"Key Implementation Details","text":"<p>Proactivity Architecture (from code analysis): - Cron Service: Timer-based polling (<code>setTimeout</code>) with priority-ordered job execution - Heartbeat: Coalescing event handler with 30min default cycle - System Events: In-memory queue (<code>src/infra/system-events.ts</code>) injected at agent turn start - Isolated Jobs: Cron can spawn fresh sessions (<code>sessionKey: \"cron:&lt;jobId&gt;\"</code>)</p> <p>Memory Retrieval (from code analysis): - Hybrid search: BM25 (FTS5) + vector similarity with weighted scoring - Daily logs: <code>memory/YYYY-MM-DD.md</code> (append-only, read today + yesterday) - Curated memory: <code>MEMORY.md</code> (optional, main session only) - Chunk indexing: 400-token chunks with 80-token overlap, embedding cache per provider</p> <p>Plugin Architecture (from code analysis): - 7 plugin types: Channel, Provider, Tool, Service, Skill, Hook, CLI - Adapter pattern: 25+ optional adapters per channel plugin - Discovery order: Config \u2192 Workspace \u2192 Global \u2192 Bundled - Examples: Mattermost (250 lines), Voice Call (400+ lines), Telegram, Discord, Slack, WhatsApp, Signal</p>"},{"location":"OpenClaw_COMPARISON/#the-strategic-question-abandon-merge-compete-or-coexist","title":"The Strategic Question: Abandon, Merge, Compete, or Coexist?","text":""},{"location":"OpenClaw_COMPARISON/#option-a-abandon-reeve","title":"Option A: Abandon Reeve","text":"<p>Rationale: OpenClaw has momentum, community, and plugins. Why reinvent the wheel?</p> <p>Counter-argument: - Reeve's conversation-level meta-skills (retrospection, self-testing) address real gaps in OpenClaw - The opinionated Desk framework offers a distinct personalization philosophy - The orchestrator pattern may prove more robust long-term</p> <p>Verdict: Premature. Reeve contributes ideas that don't yet exist in OpenClaw.</p>"},{"location":"OpenClaw_COMPARISON/#option-b-mergecontribute-to-openclaw","title":"Option B: Merge/Contribute to OpenClaw","text":"<p>Rationale: Join forces. Port Reeve's concepts as OpenClaw extensions.</p> <p>Feasibility: Medium (improved from original \"Low\" assessment) - Tech stack incompatibility (Python vs. TypeScript) \u2014 but concepts are portable - Conversation retrospection and self-testing could be implemented as OpenClaw skills/hooks - Desk structure ideas could inform workspace improvements</p> <p>What could be contributed: - Conversation-level retrospection as a scheduled cron job (~1-2 weeks) - Git auto-commit hook for workspace changes (~1-2 days) - Self-testing framework for behavior changes (~1-2 weeks) - Desk structure patterns for memory organization</p> <p>Verdict: Concepts can be shared. The fact-check estimated ~3 weeks for OpenClaw to achieve parity on conversation meta-skills.</p>"},{"location":"OpenClaw_COMPARISON/#option-c-compete-head-to-head","title":"Option C: Compete Head-to-Head","text":"<p>Rationale: Build a rival ecosystem. Aim for OpenClaw's breadth of plugins.</p> <p>Feasibility: Low - OpenClaw's 174k stars and 455+ contributors are a massive advantage - ClawHub's 31,000+ skills vs. zero Reeve marketplace - Competing on \"number of integrations\" is a resource war Reeve cannot win</p> <p>Winning Strategy (if competing): - Don't compete on breadth (number of tools) - Compete on depth (meta-skills, self-improvement, personalization) - Position as \"Jarvis\" (task executive) vs. OpenClaw's \"Her\" (conversational OS)</p> <p>Verdict: Not viable as a head-to-head competition. Differentiation is the only path.</p>"},{"location":"OpenClaw_COMPARISON/#option-d-coexist-as-complementary-systems","title":"Option D: Coexist as Complementary Systems","text":"<p>Rationale: Reeve and OpenClaw target different use cases, with genuinely different architectural strengths.</p> Dimension OpenClaw Reeve Use Case Conversational buddy, general assistant Proactive task executive, \"Chief of Staff\" Architecture All-in-one runtime Modular orchestrator Session Default Continuity (with isolation options) Isolation (with context carry-forward) Memory Plain Markdown + hybrid search Plain Markdown + opinionated structure Meta-Skills OpenProse (code/workflow improvement) Conversation-level (retrospection, self-testing) Ecosystem ClawHub (31k+ skills), 174k+ stars No marketplace, solo developer Key Strength Ecosystem, real-time interaction, OpenProse Session hygiene, Desk framework, conversation self-improvement <p>Coexistence Scenarios: 1. Independent Evolution: Different tools for different needs 2. Concept Sharing: Reeve's meta-skill patterns adopted as OpenClaw extensions 3. Potential Integration: Reeve's Pulse Queue could trigger OpenClaw sessions via API</p> <p>Verdict: This is the strongest path forward. The fact-check confirms the systems have different genuine strengths. The gap is meaningful but not insurmountable (~3 weeks of implementation). Both architectural philosophies can thrive.</p>"},{"location":"OpenClaw_COMPARISON/#what-the-research-says","title":"What the Research Says","text":"<p>Recent industry discussions (January 2026) highlight the architectural debates around agentic AI:</p> <ul> <li>\"The Agentic Architect\" - Software is negotiated with agents, not written</li> <li>\"Keep it simple, stupid: Agentic AI tools choke on complexity\" - Complexity is the enemy</li> <li>\"Agentic AI Isn't a Feature. It's a Re-Platforming\" - Fundamental shift in how we build systems</li> </ul> <p>Key Takeaway: The space is too new for there to be a \"one true architecture.\" Multiple approaches are needed to explore the design space.</p>"},{"location":"OpenClaw_COMPARISON/#community-feedback-needed","title":"Community Feedback Needed","text":"<p>This is an open question. Before investing further, the project seeks input:</p>"},{"location":"OpenClaw_COMPARISON/#questions-for-the-community","title":"Questions for the Community","text":"<ol> <li>Do conversation-level meta-skills (retrospection, self-testing) matter enough to justify a separate project?</li> <li> <p>Or could these be contributed as OpenClaw extensions?</p> </li> <li> <p>Is the \"wrapper\" bet (orchestrating Claude Code) smart or risky?</p> </li> <li>Does delegating the agent loop to Anthropic reduce maintenance burden?</li> <li> <p>Or does it create unacceptable dependency risk?</p> </li> <li> <p>Is there room for a \"Proactive First\" assistant distinct from conversational bots?</p> </li> <li>Do users want scheduled, reliable task execution (Reeve's focus)?</li> <li> <p>Or is real-time chat interaction (OpenClaw's strength) sufficient?</p> </li> <li> <p>Does the opinionated Desk framework (Goals/Responsibilities/Diary) add value over a general-purpose workspace?</p> </li> <li>Does the structured thinking framework bootstrap better personalization?</li> <li>Or is flexibility (OpenClaw's approach) more important than opinionation?</li> </ol>"},{"location":"OpenClaw_COMPARISON/#how-to-provide-feedback","title":"How to Provide Feedback","text":"<ul> <li>GitHub Issues: reeve-bot/issues</li> <li>Discussions: reeve-bot/discussions</li> <li>Twitter/X: @reubenjohn</li> <li>LinkedIn: Reuben John</li> </ul>"},{"location":"OpenClaw_COMPARISON/#relevant-resources","title":"Relevant Resources","text":"<ul> <li>OpenClaw Project: github.com/openclaw/openclaw (174k+ stars)</li> <li>Reeve Desk: github.com/reubenjohn/reeve-desk</li> <li>Desk Template: github.com/reubenjohn/reeve-desk-template</li> <li>Agentic IDE Research: github.com/reubenjohn/agentic-ide-power-user</li> <li>Fact-Check Report: <code>openclaw/findings/FINAL_REPORT.md</code> (codebase verification of all OpenClaw claims)</li> <li>OpenClaw Setup Tutorial: YouTube - Your Own 24/7 AI Assistant</li> <li>TechCrunch Coverage: Everything you need to know about OpenClaw</li> </ul>"},{"location":"OpenClaw_COMPARISON/#conclusion-complementary-not-competitive","title":"Conclusion: Complementary, Not Competitive","text":"<p>As of February 2026, the fact-check has clarified the picture. The original framing \u2014 \"opaque vs. transparent,\" \"one conversation vs. isolated sessions\" \u2014 was a false dichotomy. Both systems use transparent Markdown memory. Both support session isolation. Both have proactive scheduling.</p> <p>Where Reeve genuinely differentiates: 1. Conversation-level meta-skills \u2014 retrospection, self-testing, self-improvement for human interaction (not code workflows) 2. Opinionated Desk framework \u2014 user-centric personalization with template model, update cadences, and self-organization discipline 3. Git transparency \u2014 automatic commits with diff notifications 4. Orchestrator architecture \u2014 delegates agent loop to specialized tools, bets on decoupling</p> <p>Where OpenClaw genuinely excels: 1. Ecosystem scale \u2014 174k+ stars, ClawHub (31k+ skills), 455+ contributors 2. Proactive mechanisms \u2014 5 types vs. 1 3. OpenProse \u2014 declarative workflows and code-level self-improvement 4. Batteries-included \u2014 everything works out of the box</p> <p>The goal is not to \"beat\" OpenClaw, but to explore whether conversation-level meta-skills and the opinionated Desk framework solve real problems that general-purpose runtimes don't address. If the answer is yes, these patterns can be shared. If no, we'll have learned something valuable.</p> <p>If you have thoughts on this direction, please share them.</p>"},{"location":"debugging/","title":"Debugging and Monitoring Guide","text":"<p>This guide covers the debug and diagnostic tools available for monitoring and troubleshooting the Reeve system.</p>"},{"location":"debugging/#quick-reference","title":"Quick Reference","text":"Command Description <code>reeve-status</code> System health overview <code>reeve-logs</code> Unified log viewer <code>reeve-queue</code> Pulse queue inspector <code>uv run python -m reeve.doctor</code> Pre-flight configuration check <code>uv run python -m reeve.debug.trigger_pulse</code> Manual pulse trigger"},{"location":"debugging/#shell-scripts","title":"Shell Scripts","text":"<p>These scripts are installed to <code>/usr/local/bin/</code> during deployment and can be run from anywhere.</p>"},{"location":"debugging/#reeve-status-system-overview","title":"reeve-status - System Overview","text":"<p>Shows overall health of the Reeve system at a glance.</p> <pre><code>reeve-status\n</code></pre> <p>Output: <pre><code>=== Reeve Status ===\nServices:\n  reeve-daemon:   [OK] running (pid 12345, uptime 2d 4h)\n  reeve-telegram: [OK] running (pid 12346, uptime 2d 4h)\n\nAPI: [OK] healthy (http://127.0.0.1:8765)\n\nPulse Queue:\n  Pending: 2 | Overdue: 0 | Failed: 0\n\nRecent Pulses (last 5):\n  [122] [OK] 23:12 Hourly heartbeat (morning): Rev... - 45s\n  [121] [OK] 23:11 Hourly heartbeat (morning): Rev... - 38s\n\nLast Heartbeat: 23:12 (8 min ago) [OK]\nErrors (last hour): 0\n</code></pre></p> <p>What it checks: - Service status (reeve-daemon, reeve-telegram) with PID and uptime - API health endpoint responsiveness - Pulse queue statistics (pending, overdue, failed) - Recent pulse execution history - Last heartbeat timestamp and age - Error count from journalctl</p> <p>Exit Codes: - 0: System healthy - 1: Issues detected (service down, overdue pulses, failed pulses, stale heartbeat, errors in logs)</p>"},{"location":"debugging/#reeve-logs-unified-log-viewer","title":"reeve-logs - Unified Log Viewer","text":"<p>View logs from multiple sources with a single command.</p> <pre><code>reeve-logs              # Follow daemon logs (default)\nreeve-logs daemon       # Follow daemon logs\nreeve-logs telegram     # Follow telegram listener logs\nreeve-logs heartbeat    # Tail heartbeat log file\nreeve-logs all          # Interleave all logs\nreeve-logs -n 50        # Show last 50 lines (no follow)\nreeve-logs -n 100 telegram  # Last 100 telegram lines\n</code></pre> <p>Sources: | Source | Description | |--------|-------------| | <code>daemon</code> | Reeve daemon logs via journalctl (default) | | <code>telegram</code> | Telegram listener logs via journalctl | | <code>heartbeat</code> | Heartbeat log file (<code>~/.reeve/logs/heartbeat.log</code>) | | <code>credential-keepalive</code> | Credential keepalive log (<code>~/.reeve/logs/credential-keepalive.log</code>) | | <code>all</code> | Interleave daemon + telegram + heartbeat |</p> <p>Options: | Option | Description | |--------|-------------| | <code>-n N</code> | Show last N lines without following | | <code>-h</code> | Show help message |</p>"},{"location":"debugging/#reeve-queue-pulse-queue-inspector","title":"reeve-queue - Pulse Queue Inspector","text":"<p>Inspect and filter the pulse queue directly.</p> <pre><code>reeve-queue             # Show pending pulses (default)\nreeve-queue pending     # Show pending pulses\nreeve-queue failed      # Show failed pulses\nreeve-queue completed   # Show recent completed pulses\nreeve-queue overdue     # Show overdue pulses (past scheduled time)\nreeve-queue all         # Show all recent pulses\nreeve-queue 123         # Show details for pulse #123\n</code></pre> <p>List View Output: <pre><code>=== Pending Pulses ===\nID    Priority  Scheduled          Prompt\n--------------------------------------------------------------\n123   normal    2026-02-04 00:00   Hourly heartbeat (morning): Review...\n124   high      2026-02-04 00:05   Telegram message from Alice: Can we...\n\nTotal: 2 pending\n</code></pre></p> <p>Detail View Output (reeve-queue 123): <pre><code>=== Pulse #123 ===\n\nStatus:      completed\nPriority:    normal\nScheduled:   2026-02-04 00:00:00\nExecuted:    2026-02-04 00:00:02\nDuration:    45s (45123ms)\n\nPrompt:\n  Hourly heartbeat (morning): Review calendar and check for updates\n\nTags: [\"heartbeat\", \"morning\"]\n\nCreated By:  heartbeat_cron\nCreated At:  2026-02-04 00:00:00\nSession ID:  abc123-def456\nRetries:     0 / 3\n</code></pre></p>"},{"location":"debugging/#python-debug-tools","title":"Python Debug Tools","text":""},{"location":"debugging/#reevedoctor-configuration-validator","title":"reeve.doctor - Configuration Validator","text":"<p>Comprehensive pre-flight check that validates the entire Reeve stack before deployment or after configuration changes.</p> <pre><code>uv run python -m reeve.doctor\n</code></pre> <p>Output: <pre><code>=== Reeve Doctor ===\n\nEnvironment:\n  [check] PULSE_API_TOKEN set\n  [check] REEVE_DESK_PATH=/home/user/reeve_desk\n  [check] PULSE_DB_URL configured\n  ! HAPI_COMMAND not set (using default 'hapi')\n  ! PULSE_API_PORT not set (using default 8765)\n\nDatabase:\n  [check] Database exists: /home/user/.reeve/pulse_queue.db\n  [check] Can connect and query\n  [check] Migrations current (07ce7ae63b4a)\n\nMCP Configuration:\n  [check] Config file: /home/user/.config/claude-code/mcp_config.json\n  [check] pulse-queue server configured\n  [check] telegram-notifier server configured\n\nDesk Permissions:\n  [check] Settings file: /home/user/reeve_desk/.claude/settings.json\n  [check] mcp__pulse-queue__schedule_pulse allowed\n  [check] mcp__pulse-queue__list_upcoming_pulses allowed\n  [check] mcp__pulse-queue__cancel_pulse allowed\n  [check] mcp__pulse-queue__reschedule_pulse allowed\n  [check] mcp__telegram-notifier__send_notification allowed\n\nCommands:\n  [check] hapi command available (/usr/local/bin/hapi)\n  [check] uv command available (/home/user/.local/bin/uv)\n\nServices:\n  [check] API responding at http://127.0.0.1:8765\n\nAll required checks passed! (2 warnings)\n</code></pre></p> <p>Checks performed:</p> Category Checks Environment <code>PULSE_API_TOKEN</code>, <code>REEVE_DESK_PATH</code>, <code>PULSE_DB_URL</code>, optional vars Database File exists, can connect, migrations at head MCP Configuration Config file exists, pulse-queue and telegram-notifier servers configured Desk Permissions Required MCP tool permissions in allow list Commands <code>hapi</code> and <code>uv</code> available in PATH Services API health endpoint check <p>Exit Codes: - 0: All required checks passed (may have warnings) - 1: One or more required checks failed</p>"},{"location":"debugging/#reevedebugtrigger_pulse-manual-pulse-trigger","title":"reeve.debug.trigger_pulse - Manual Pulse Trigger","text":"<p>Manually trigger pulses for testing without going through the daemon scheduler.</p> <pre><code># Basic usage\nuv run python -m reeve.debug.trigger_pulse \"Test prompt\"\n\n# With priority\nuv run python -m reeve.debug.trigger_pulse --priority high \"Urgent test\"\n\n# Dry run (schedule and mark complete without calling Hapi)\nuv run python -m reeve.debug.trigger_pulse --dry-run \"Check what would happen\"\n\n# Schedule only (add to queue, don't execute)\nuv run python -m reeve.debug.trigger_pulse --schedule-only \"Execute later\"\n\n# Verbose output (show full stdout/stderr)\nuv run python -m reeve.debug.trigger_pulse -v \"Test with output\"\n</code></pre> <p>Options:</p> Option Description <code>--priority</code> Set priority: critical, high, normal (default), low, deferred <code>--dry-run</code> Schedule and mark complete without executing Hapi <code>--schedule-only</code> Only schedule to queue, don't execute <code>-v, --verbose</code> Show full stdout/stderr from execution <p>Use cases: - Testing pulse execution end-to-end - Debugging Hapi/Claude Code integration - Verifying queue operations - Testing prompt formatting</p>"},{"location":"debugging/#api-endpoints","title":"API Endpoints","text":"<p>Debug information is also available via the REST API:</p> Endpoint Description <code>GET /api/health</code> Health check (returns 200 if API is running) <code>GET /api/pulse/{id}</code> Get details for a specific pulse <code>GET /api/pulse/list?status=X</code> List pulses filtered by status <code>GET /api/pulse/stats</code> Queue statistics summary <code>GET /api/stats</code> Execution statistics <p>Example API calls: <pre><code># Health check\ncurl http://localhost:8765/api/health\n\n# Get pulse details\ncurl -H \"Authorization: Bearer $PULSE_API_TOKEN\" \\\n  http://localhost:8765/api/pulse/123\n\n# List failed pulses\ncurl -H \"Authorization: Bearer $PULSE_API_TOKEN\" \\\n  http://localhost:8765/api/pulse/list?status=failed\n\n# Queue statistics\ncurl -H \"Authorization: Bearer $PULSE_API_TOKEN\" \\\n  http://localhost:8765/api/pulse/stats\n</code></pre></p>"},{"location":"debugging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"debugging/#common-issues","title":"Common Issues","text":""},{"location":"debugging/#daemon-not-starting","title":"Daemon not starting","text":"<ol> <li>Run <code>uv run python -m reeve.doctor</code> to check configuration</li> <li>Check systemd logs: <code>journalctl -u reeve-daemon -n 50</code></li> <li>Verify database migrations: <code>uv run alembic current</code></li> <li>Check <code>.env</code> file exists and is readable</li> </ol>"},{"location":"debugging/#pulses-not-executing","title":"Pulses not executing","text":"<ol> <li>Check for overdue pulses: <code>reeve-queue overdue</code></li> <li>Review daemon logs: <code>reeve-logs daemon</code></li> <li>Verify Hapi command: <code>which hapi</code> or check <code>$HAPI_COMMAND</code></li> <li>Test manually: <code>uv run python -m reeve.debug.trigger_pulse --dry-run \"Test\"</code></li> </ol>"},{"location":"debugging/#permission-errors","title":"Permission errors","text":"<ol> <li>Check Desk permissions: <code>cat $REEVE_DESK_PATH/.claude/settings.json</code></li> <li>Verify MCP config: <code>cat ~/.config/claude-code/mcp_config.json</code></li> <li>Run doctor to check all permissions: <code>uv run python -m reeve.doctor</code></li> </ol>"},{"location":"debugging/#heartbeat-missing","title":"Heartbeat missing","text":"<ol> <li>Check cron is running: <code>crontab -l | grep reeve</code></li> <li>Review heartbeat log: <code>reeve-logs heartbeat -n 20</code></li> <li>Verify heartbeat script: <code>/usr/local/bin/reeve-heartbeat</code></li> <li>Check API is accessible from cron environment</li> </ol>"},{"location":"debugging/#credential-refresh-failing","title":"Credential refresh failing","text":"<ol> <li>Check cron is running: <code>crontab -l | grep credential</code></li> <li>Review keepalive log: <code>cat ~/.reeve/logs/credential-keepalive.log</code></li> <li>Run manually: <code>/usr/local/bin/reeve-credential-keepalive</code></li> <li>Check credentials file exists: <code>ls -la ~/.claude/.credentials.json</code></li> <li>Verify python3 is available: <code>which python3</code></li> </ol>"},{"location":"debugging/#api-not-responding","title":"API not responding","text":"<ol> <li>Check daemon is running: <code>systemctl status reeve-daemon</code></li> <li>Verify port is correct: <code>echo $PULSE_API_PORT</code> (default: 8765)</li> <li>Test locally: <code>curl http://127.0.0.1:8765/api/health</code></li> <li>Check firewall rules if accessing remotely</li> </ol>"},{"location":"debugging/#log-locations","title":"Log Locations","text":"Log Location Access Daemon logs systemd journal <code>journalctl -u reeve-daemon</code> Telegram logs systemd journal <code>journalctl -u reeve-telegram</code> Heartbeat log <code>~/.reeve/logs/heartbeat.log</code> <code>cat</code> or <code>reeve-logs heartbeat</code> Health check log <code>~/.reeve/logs/health_check.log</code> <code>cat</code> Credential keepalive log <code>~/.reeve/logs/credential-keepalive.log</code> <code>cat</code>"},{"location":"debugging/#database-inspection","title":"Database Inspection","text":"<p>For advanced debugging, you can query the database directly:</p> <pre><code># Open database\nsqlite3 ~/.reeve/pulse_queue.db\n\n# View schema\n.schema pulses\n\n# Count pulses by status\nSELECT status, COUNT(*) FROM pulses GROUP BY status;\n\n# Find overdue pulses\nSELECT id, scheduled_at, prompt FROM pulses\nWHERE status='pending' AND scheduled_at &lt; datetime('now');\n\n# View recent failures with errors\nSELECT id, executed_at, error_message FROM pulses\nWHERE status='failed' ORDER BY executed_at DESC LIMIT 5;\n</code></pre>"},{"location":"architecture/","title":"Architecture Documentation","text":"<p>This directory contains the technical architecture documentation for the Reeve Bot pulse queue system.</p>"},{"location":"architecture/#documents","title":"Documents","text":"Document Description When to Read Project Structure Directory layout and file organization Starting development, understanding codebase Pulse Queue Design Database schema, models, queue logic Working on pulse scheduling or storage MCP Integration MCP server specifications Building or modifying MCP tools Daemon &amp; API Daemon orchestration and HTTP API Working on execution or external triggers Deployment Production deployment guide Deploying to production"},{"location":"architecture/#quick-reference","title":"Quick Reference","text":""},{"location":"architecture/#core-components","title":"Core Components","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Reeve Bot                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  MCP Servers          \u2502  HTTP API        \u2502  Integrations    \u2502\n\u2502  \u251c\u2500 Pulse Queue       \u2502  \u251c\u2500 /schedule    \u2502  \u2514\u2500 Telegram     \u2502\n\u2502  \u2514\u2500 Telegram Notifier \u2502  \u251c\u2500 /upcoming    \u2502                  \u2502\n\u2502                       \u2502  \u2514\u2500 /health      \u2502                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     Pulse Daemon                            \u2502\n\u2502  \u251c\u2500 Scheduler Loop (1s polling)                             \u2502\n\u2502  \u251c\u2500 Executor (Hapi subprocess)                              \u2502\n\u2502  \u2514\u2500 Retry Logic (exponential backoff)                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     Pulse Queue                             \u2502\n\u2502  \u2514\u2500 SQLite + SQLAlchemy (async)                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Pulse Creation: MCP tool / HTTP API / Telegram \u2192 PulseQueue \u2192 SQLite</li> <li>Pulse Execution: Daemon polls \u2192 PulseExecutor \u2192 Hapi subprocess</li> <li>Notifications: Hapi session \u2192 Telegram Notifier MCP \u2192 User</li> </ol>"},{"location":"architecture/#see-also","title":"See Also","text":"<ul> <li>Implementation Roadmap - Phase-by-phase implementation details</li> <li>MCP Setup Guide - Configuring MCP servers for Claude Code</li> </ul>"},{"location":"architecture/daemon-api/","title":"Pulse Daemon and HTTP API","text":""},{"location":"architecture/daemon-api/#overview","title":"Overview","text":"<p>The Pulse Daemon is the long-running process that powers Reeve's proactive behavior. It runs continuously in the background, managing three concurrent services:</p> <ol> <li>Pulse Scheduler: Checks for due pulses every second and executes them</li> <li>HTTP API: Accepts external pulse triggers (Telegram, Email, etc.)</li> <li>MCP Servers: Spawned on-demand when Reeve needs to interact with the queue</li> </ol>"},{"location":"architecture/daemon-api/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Pulse Daemon Process                   \u2502\n\u2502                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Scheduler  \u2502  \u2502  HTTP API   \u2502  \u2502 MCP Servers \u2502   \u2502\n\u2502  \u2502   Loop      \u2502  \u2502  (FastAPI)  \u2502  \u2502  (stdio)    \u2502   \u2502\n\u2502  \u2502             \u2502  \u2502             \u2502  \u2502             \u2502   \u2502\n\u2502  \u2502  Every 1s:  \u2502  \u2502 POST /pulse \u2502  \u2502 On-demand:  \u2502   \u2502\n\u2502  \u2502  - Query DB \u2502  \u2502 GET /status \u2502  \u2502 - Started   \u2502   \u2502\n\u2502  \u2502  - Execute  \u2502  \u2502 GET /health \u2502  \u2502   by Reeve  \u2502   \u2502\n\u2502  \u2502    pulses   \u2502  \u2502             \u2502  \u2502 - stdio I/O \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502         \u2502                \u2502                            \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502\n\u2502                                      \u25bc                \u2502\n\u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502                              \u2502 PulseQueue    \u2502        \u2502\n\u2502                              \u2502 (SQLAlchemy)  \u2502        \u2502\n\u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u25bc\n                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                \u2502  SQLite DB  \u2502\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/daemon-api/#daemon-implementation","title":"Daemon Implementation","text":"<p>Module: <code>src/reeve/pulse/daemon.py</code></p> <pre><code>\"\"\"\nPulse Daemon - Main entry point for the long-running background process.\n\nThis daemon runs three concurrent asyncio tasks:\n1. Pulse scheduler (checks queue every 1 second)\n2. HTTP API server (FastAPI on port 8765)\n3. Signal handlers (graceful shutdown)\n\nUsage:\n    # Development\n    uv run python -m reeve.pulse\n\n    # Production (via systemd)\n    systemctl start reeve-daemon\n\"\"\"\n\nimport asyncio\nimport signal\nimport sys\nimport logging\nfrom datetime import datetime, timezone\nfrom pathlib import Path\n\nfrom reeve.pulse.queue import PulseQueue\nfrom reeve.pulse.executor import PulseExecutor\nfrom reeve.pulse.enums import PulseStatus\nfrom reeve.api.server import create_api_server\nfrom reeve.utils.config import load_config\nfrom reeve.utils.logging import setup_logging\n\n\nclass PulseDaemon:\n    \"\"\"\n    Main daemon process that orchestrates pulse execution and API serving.\n    \"\"\"\n\n    def __init__(self, config: dict):\n        self.config = config\n        self.logger = logging.getLogger(\"reeve.daemon\")\n\n        # Initialize components\n        self.queue = PulseQueue(config[\"database_url\"])\n        self.executor = PulseExecutor(config[\"hapi_command\"], config[\"desk_path\"])\n\n        # State\n        self.running = False\n        self.scheduler_task = None\n        self.api_task = None\n\n    async def start(self):\n        \"\"\"Start all daemon services.\"\"\"\n        self.logger.info(\"Starting Pulse Daemon...\")\n        self.running = True\n\n        # Setup signal handlers for graceful shutdown\n        for sig in (signal.SIGTERM, signal.SIGINT):\n            signal.signal(sig, self._signal_handler)\n\n        # Start concurrent tasks\n        self.scheduler_task = asyncio.create_task(self._scheduler_loop())\n        self.api_task = asyncio.create_task(self._run_api_server())\n\n        self.logger.info(\"Pulse Daemon started successfully\")\n\n        # Wait for shutdown signal\n        await asyncio.gather(\n            self.scheduler_task,\n            self.api_task,\n            return_exceptions=True\n        )\n\n    async def _scheduler_loop(self):\n        \"\"\"\n        Main scheduler loop: check for due pulses every second and execute them.\n        \"\"\"\n        self.logger.info(\"Scheduler loop started\")\n\n        while self.running:\n            try:\n                # Get due pulses (up to 10 at a time)\n                pulses = await self.queue.get_due_pulses(limit=10)\n\n                # Execute each pulse\n                for pulse in pulses:\n                    self.logger.info(\n                        f\"Executing pulse {pulse.id}: {pulse.prompt[:50]}...\"\n                    )\n\n                    # Mark as processing\n                    success = await self.queue.mark_processing(pulse.id)\n                    if not success:\n                        self.logger.warning(\n                            f\"Pulse {pulse.id} already processing/completed, skipping\"\n                        )\n                        continue\n\n                    # Execute pulse (async, non-blocking)\n                    asyncio.create_task(self._execute_pulse(pulse))\n\n                # Sleep 1 second before next check\n                await asyncio.sleep(1)\n\n            except Exception as e:\n                self.logger.error(f\"Error in scheduler loop: {e}\", exc_info=True)\n                await asyncio.sleep(5)  # Back off on error\n\n    async def _execute_pulse(self, pulse):\n        \"\"\"\n        Execute a single pulse by launching a Hapi session.\n\n        Args:\n            pulse: The Pulse model instance to execute\n        \"\"\"\n        start_time = datetime.now(timezone.utc)\n\n        try:\n            # Build the full prompt (including sticky notes)\n            full_prompt = self._build_prompt(pulse)\n\n            # Execute via PulseExecutor\n            result = await self.executor.execute(\n                prompt=full_prompt,\n                session_id=pulse.session_id,\n                working_dir=self.config[\"desk_path\"]\n            )\n\n            # Calculate duration\n            duration_ms = int(\n                (datetime.now(timezone.utc) - start_time).total_seconds() * 1000\n            )\n\n            # Mark as completed\n            await self.queue.mark_completed(pulse.id, duration_ms)\n\n            self.logger.info(\n                f\"Pulse {pulse.id} completed successfully in {duration_ms}ms\"\n            )\n\n        except Exception as e:\n            self.logger.error(f\"Pulse {pulse.id} failed: {e}\", exc_info=True)\n\n            # Mark as failed (will auto-retry if retries remaining)\n            retry_pulse_id = await self.queue.mark_failed(\n                pulse.id,\n                error_message=str(e),\n                should_retry=True\n            )\n\n            if retry_pulse_id:\n                self.logger.info(\n                    f\"Pulse {pulse.id} scheduled for retry as pulse {retry_pulse_id}\"\n                )\n\n    def _build_prompt(self, pulse) -&gt; str:\n        \"\"\"\n        Build the full prompt including sticky notes.\n\n        Args:\n            pulse: The Pulse model instance\n\n        Returns:\n            Full prompt string with formatted sticky notes\n        \"\"\"\n        parts = []\n\n        # Add sticky notes if present\n        if pulse.sticky_notes:\n            parts.append(\"\ud83d\udccc Reminders:\")\n            for note in pulse.sticky_notes:\n                parts.append(f\"  - {note}\")\n            parts.append(\"\")  # Blank line separator\n\n        # Add main prompt\n        parts.append(pulse.prompt)\n\n        return \"\\n\".join(parts)\n\n    async def _run_api_server(self):\n        \"\"\"Run the HTTP API server.\"\"\"\n        app = create_api_server(self.queue, self.config)\n\n        import uvicorn\n\n        config = uvicorn.Config(\n            app,\n            host=self.config.get(\"api_host\", \"127.0.0.1\"),\n            port=self.config.get(\"api_port\", 8765),\n            log_level=\"info\"\n        )\n\n        server = uvicorn.Server(config)\n        await server.serve()\n\n    def _signal_handler(self, signum, frame):\n        \"\"\"Handle shutdown signals gracefully.\"\"\"\n        self.logger.info(f\"Received signal {signum}, shutting down...\")\n        self.running = False\n\n        # Cancel tasks\n        if self.scheduler_task:\n            self.scheduler_task.cancel()\n        if self.api_task:\n            self.api_task.cancel()\n\n\nasync def main():\n    \"\"\"Entry point for the daemon.\"\"\"\n    # Load configuration\n    config = load_config()\n\n    # Setup logging\n    setup_logging(config.get(\"log_level\", \"INFO\"), config.get(\"log_file\"))\n\n    # Start daemon\n    daemon = PulseDaemon(config)\n    await daemon.start()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"architecture/daemon-api/#pulse-executor","title":"Pulse Executor","text":"<p>Module: <code>src/reeve/pulse/executor.py</code></p> <pre><code>\"\"\"\nPulse Executor - Launches Hapi sessions to execute pulses.\n\nThis module handles the actual execution of pulses by spawning Hapi/Claude Code\nsessions with the pulse's prompt as the initial context.\n\"\"\"\n\nimport asyncio\nimport logging\nfrom pathlib import Path\nfrom typing import Optional\n\n\nclass PulseExecutor:\n    \"\"\"\n    Executes pulses by launching Hapi sessions.\n    \"\"\"\n\n    def __init__(self, hapi_command: str, desk_path: str):\n        \"\"\"\n        Initialize the executor.\n\n        Args:\n            hapi_command: Path to Hapi executable (e.g., \"hapi\", \"/usr/local/bin/hapi\")\n            desk_path: Path to the user's Desk directory (working directory for Hapi)\n        \"\"\"\n        self.hapi_command = hapi_command\n        self.desk_path = Path(desk_path).expanduser()\n        self.logger = logging.getLogger(\"reeve.executor\")\n\n    async def execute(\n        self,\n        prompt: str,\n        session_id: Optional[str] = None,\n        working_dir: Optional[str] = None\n    ) -&gt; dict:\n        \"\"\"\n        Execute a pulse by launching a Hapi session.\n\n        Args:\n            prompt: The instruction/context for Reeve\n            session_id: Optional session ID to resume\n            working_dir: Override working directory (defaults to desk_path)\n\n        Returns:\n            Execution result dict with stdout, stderr, return_code\n\n        Raises:\n            RuntimeError: If Hapi execution fails\n        \"\"\"\n        cwd = Path(working_dir).expanduser() if working_dir else self.desk_path\n\n        # Build Hapi command\n        cmd = [self.hapi_command, \"run\"]\n\n        # Add session resume flag if provided\n        if session_id:\n            cmd.extend([\"--resume\", session_id])\n\n        # Add prompt\n        cmd.extend([\"--text\", prompt])\n\n        self.logger.debug(f\"Executing: {' '.join(cmd)} (cwd: {cwd})\")\n\n        # Execute Hapi as subprocess\n        process = await asyncio.create_subprocess_exec(\n            *cmd,\n            cwd=cwd,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n\n        # Wait for completion\n        stdout, stderr = await process.communicate()\n\n        result = {\n            \"stdout\": stdout.decode(\"utf-8\"),\n            \"stderr\": stderr.decode(\"utf-8\"),\n            \"return_code\": process.returncode\n        }\n\n        # Check for errors\n        if process.returncode != 0:\n            raise RuntimeError(\n                f\"Hapi execution failed (exit code {process.returncode}): {result['stderr']}\"\n            )\n\n        return result\n</code></pre>"},{"location":"architecture/daemon-api/#http-api-server","title":"HTTP API Server","text":"<p>Module: <code>src/reeve/api/server.py</code></p> <pre><code>\"\"\"\nHTTP API Server - REST endpoints for external pulse triggers.\n\nThis API allows external systems (Telegram listeners, webhooks, etc.) to\ntrigger pulses without using the MCP protocol.\n\nEndpoints:\n    POST /api/pulse/trigger - Create a new pulse\n    GET  /api/pulse/upcoming - List upcoming pulses\n    GET  /api/health - Health check\n    GET  /api/status - Daemon status\n\"\"\"\n\nfrom fastapi import FastAPI, HTTPException, Depends, Header\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, Literal\nfrom datetime import datetime, timezone, timedelta\nimport os\n\nfrom reeve.pulse.queue import PulseQueue\nfrom reeve.pulse.enums import PulsePriority\n\n\ndef create_api_server(queue: PulseQueue, config: dict) -&gt; FastAPI:\n    \"\"\"\n    Create and configure the FastAPI application.\n\n    Args:\n        queue: The PulseQueue instance\n        config: Daemon configuration\n\n    Returns:\n        FastAPI app instance\n    \"\"\"\n    app = FastAPI(\n        title=\"Reeve Pulse API\",\n        description=\"HTTP API for triggering pulses from external systems\",\n        version=\"0.1.0\"\n    )\n\n    # API Token authentication\n    API_TOKEN = config.get(\"api_token\", os.getenv(\"PULSE_API_TOKEN\"))\n\n    async def verify_token(authorization: str = Header(None)):\n        \"\"\"Verify API token from Authorization header.\"\"\"\n        if not API_TOKEN:\n            return True  # No token configured, allow all (dev mode)\n\n        if not authorization or not authorization.startswith(\"Bearer \"):\n            raise HTTPException(401, \"Missing or invalid Authorization header\")\n\n        token = authorization.replace(\"Bearer \", \"\")\n        if token != API_TOKEN:\n            raise HTTPException(403, \"Invalid API token\")\n\n        return True\n\n    # ========================================================================\n    # Request/Response Models\n    # ========================================================================\n\n    class TriggerPulseRequest(BaseModel):\n        \"\"\"Request body for triggering a pulse.\"\"\"\n\n        prompt: str = Field(\n            ...,\n            description=\"The instruction/context for Reeve\",\n            min_length=10,\n            max_length=2000\n        )\n\n        scheduled_at: str = Field(\n            default=\"now\",\n            description=\"When to execute: 'now', ISO timestamp, or 'in X minutes/hours'\",\n            examples=[\"now\", \"2026-01-20T09:00:00Z\", \"in 5 minutes\"]\n        )\n\n        priority: Literal[\"critical\", \"high\", \"normal\", \"low\", \"deferred\"] = Field(\n            default=\"high\",\n            description=\"Priority level (external events default to 'high')\"\n        )\n\n        source: str = Field(\n            default=\"external\",\n            description=\"Source identifier (e.g., 'telegram', 'email', 'webhook')\"\n        )\n\n        tags: Optional[list[str]] = Field(\n            default=None,\n            description=\"Optional tags for categorization\"\n        )\n\n    class TriggerPulseResponse(BaseModel):\n        \"\"\"Response after triggering a pulse.\"\"\"\n\n        pulse_id: int\n        scheduled_at: str\n        message: str\n\n    # ========================================================================\n    # Endpoints\n    # ========================================================================\n\n    @app.post(\"/api/pulse/trigger\", response_model=TriggerPulseResponse)\n    async def trigger_pulse(\n        request: TriggerPulseRequest,\n        authorized: bool = Depends(verify_token)\n    ):\n        \"\"\"\n        Trigger a new pulse (create and schedule).\n\n        This is the primary endpoint for external systems to inject events\n        into Reeve's attention queue.\n\n        Example:\n            curl -X POST http://localhost:8765/api/pulse/trigger \\\\\n                 -H \"Authorization: Bearer your_token_here\" \\\\\n                 -H \"Content-Type: application/json\" \\\\\n                 -d '{\n                   \"prompt\": \"Telegram message from Alice: Can we meet tomorrow?\",\n                   \"scheduled_at\": \"now\",\n                   \"priority\": \"high\",\n                   \"source\": \"telegram\"\n                 }'\n        \"\"\"\n        # Parse scheduled_at\n        if request.scheduled_at == \"now\":\n            scheduled_at = datetime.now(timezone.utc)\n        elif request.scheduled_at.startswith(\"in \"):\n            # Simple relative time parsing\n            parts = request.scheduled_at[3:].split()\n            amount = int(parts[0])\n            unit = parts[1].rstrip(\"s\")\n\n            if unit == \"minute\":\n                scheduled_at = datetime.now(timezone.utc) + timedelta(minutes=amount)\n            elif unit == \"hour\":\n                scheduled_at = datetime.now(timezone.utc) + timedelta(hours=amount)\n            else:\n                raise HTTPException(400, f\"Unsupported time unit: {unit}\")\n        else:\n            # Assume ISO 8601\n            scheduled_at = datetime.fromisoformat(request.scheduled_at.replace(\"Z\", \"+00:00\"))\n\n        # Create pulse\n        pulse_id = await queue.schedule_pulse(\n            scheduled_at=scheduled_at,\n            prompt=request.prompt,\n            priority=PulsePriority(request.priority),\n            tags=request.tags,\n            created_by=request.source\n        )\n\n        return TriggerPulseResponse(\n            pulse_id=pulse_id,\n            scheduled_at=scheduled_at.isoformat(),\n            message=f\"Pulse {pulse_id} scheduled successfully\"\n        )\n\n    @app.get(\"/api/pulse/upcoming\")\n    async def list_upcoming(\n        limit: int = 20,\n        authorized: bool = Depends(verify_token)\n    ):\n        \"\"\"List upcoming pulses.\"\"\"\n        pulses = await queue.get_upcoming_pulses(limit=limit)\n\n        return {\n            \"count\": len(pulses),\n            \"pulses\": [\n                {\n                    \"id\": p.id,\n                    \"scheduled_at\": p.scheduled_at.isoformat(),\n                    \"priority\": p.priority.value,\n                    \"prompt\": p.prompt[:100] + \"...\" if len(p.prompt) &gt; 100 else p.prompt,\n                    \"status\": p.status.value,\n                }\n                for p in pulses\n            ]\n        }\n\n    @app.get(\"/api/health\")\n    async def health_check():\n        \"\"\"Health check endpoint (no auth required).\"\"\"\n        return {\"status\": \"healthy\", \"service\": \"reeve-pulse-daemon\"}\n\n    @app.get(\"/api/status\")\n    async def daemon_status(authorized: bool = Depends(verify_token)):\n        \"\"\"Daemon status and statistics.\"\"\"\n        # TODO: Add metrics (pulses executed, failures, avg duration)\n        return {\n            \"status\": \"running\",\n            \"uptime_seconds\": 0,  # TODO: Track start time\n            \"database\": config[\"database_url\"],\n        }\n\n    return app\n</code></pre>"},{"location":"architecture/daemon-api/#configuration-management","title":"Configuration Management","text":"<p>Module: <code>src/reeve/utils/config.py</code></p> <pre><code>\"\"\"\nConfiguration management for Pulse Daemon.\n\nLoads configuration from:\n1. Environment variables\n2. .env file\n3. Default values\n\"\"\"\n\nimport os\nfrom pathlib import Path\nfrom typing import Optional\n\n\ndef load_config() -&gt; dict:\n    \"\"\"\n    Load daemon configuration.\n\n    Returns:\n        Configuration dictionary\n    \"\"\"\n    # Load .env file if present\n    _load_dotenv()\n\n    return {\n        # Database\n        \"database_url\": _get_db_url(),\n\n        # Hapi\n        \"hapi_command\": os.getenv(\"HAPI_COMMAND\", \"hapi\"),\n        \"desk_path\": os.getenv(\"REEVE_DESK_PATH\", \"~/my_reeve\"),\n\n        # API\n        \"api_host\": os.getenv(\"PULSE_API_HOST\", \"127.0.0.1\"),\n        \"api_port\": int(os.getenv(\"PULSE_API_PORT\", \"8765\")),\n        \"api_token\": os.getenv(\"PULSE_API_TOKEN\"),\n\n        # Logging\n        \"log_level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),\n        \"log_file\": os.getenv(\"LOG_FILE\", \"~/.reeve/logs/daemon.log\"),\n    }\n\n\ndef _get_db_url() -&gt; str:\n    \"\"\"Get database URL.\"\"\"\n    db_path = os.getenv(\"PULSE_DB_PATH\", \"~/.reeve/pulse_queue.db\")\n    db_path = Path(db_path).expanduser()\n\n    # Ensure directory exists\n    db_path.parent.mkdir(parents=True, exist_ok=True)\n\n    return f\"sqlite+aiosqlite:///{db_path}\"\n\n\ndef _load_dotenv():\n    \"\"\"Load .env file from project root.\"\"\"\n    env_file = Path(__file__).parent.parent.parent / \".env\"\n\n    if env_file.exists():\n        with open(env_file) as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith(\"#\") and \"=\" in line:\n                    key, value = line.split(\"=\", 1)\n                    os.environ.setdefault(key.strip(), value.strip())\n</code></pre>"},{"location":"architecture/daemon-api/#external-integration-example-telegram-listener","title":"External Integration Example: Telegram Listener","text":"<p>Updated: <code>src/reeve/integrations/telegram.py</code></p> <pre><code>\"\"\"\nTelegram Integration - Listens for messages and triggers pulses.\n\nThis replaces the prototype telegram_prototype/goose_telegram_listener.py\nwith a production-ready integration that POSTs to the Pulse API.\n\"\"\"\n\nimport time\nimport requests\nimport os\nfrom pathlib import Path\n\n\nclass TelegramListener:\n    \"\"\"Polls Telegram for messages and triggers pulses via HTTP API.\"\"\"\n\n    def __init__(self):\n        self.bot_token = os.getenv(\"TELEGRAM_BOT_TOKEN\")\n        self.api_url = os.getenv(\"PULSE_API_URL\", \"http://localhost:8765\")\n        self.api_token = os.getenv(\"PULSE_API_TOKEN\")\n\n        if not self.bot_token:\n            raise ValueError(\"TELEGRAM_BOT_TOKEN required\")\n\n    def run(self):\n        \"\"\"Main polling loop.\"\"\"\n        print(f\"\ud83e\udd16 Telegram listener started, posting to {self.api_url}\")\n        last_update_id = None\n\n        while True:\n            updates = self._get_updates(last_update_id)\n\n            if updates and \"result\" in updates:\n                for update in updates[\"result\"]:\n                    last_update_id = update[\"update_id\"] + 1\n\n                    if \"message\" in update and \"text\" in update[\"message\"]:\n                        self._handle_message(update[\"message\"])\n\n            time.sleep(1)\n\n    def _get_updates(self, offset=None):\n        \"\"\"Poll Telegram API for updates.\"\"\"\n        url = f\"https://api.telegram.org/bot{self.bot_token}/getUpdates\"\n        try:\n            response = requests.get(url, params={\"timeout\": 100, \"offset\": offset})\n            return response.json()\n        except Exception as e:\n            print(f\"Error polling Telegram: {e}\")\n            return None\n\n    def _handle_message(self, message):\n        \"\"\"Trigger a pulse for this message.\"\"\"\n        user = message[\"from\"].get(\"first_name\", \"User\")\n        text = message[\"text\"]\n\n        prompt = f\"\ud83d\udce9 Telegram message from {user}: {text}\"\n        print(f\"\\n{prompt}\")\n\n        # POST to Pulse API\n        try:\n            response = requests.post(\n                f\"{self.api_url}/api/pulse/trigger\",\n                headers={\"Authorization\": f\"Bearer {self.api_token}\"},\n                json={\n                    \"prompt\": prompt,\n                    \"scheduled_at\": \"now\",\n                    \"priority\": \"high\",\n                    \"source\": \"telegram\",\n                    \"tags\": [\"telegram\", \"user_message\"]\n                },\n                timeout=5\n            )\n\n            if response.ok:\n                result = response.json()\n                print(f\"\u2713 Pulse {result['pulse_id']} triggered\")\n            else:\n                print(f\"\u2717 API error: {response.status_code} {response.text}\")\n\n        except Exception as e:\n            print(f\"\u2717 Failed to trigger pulse: {e}\")\n\n\nif __name__ == \"__main__\":\n    listener = TelegramListener()\n    listener.run()\n</code></pre>"},{"location":"architecture/daemon-api/#summary","title":"Summary","text":"<p>Daemon (<code>daemon.py</code>): - Orchestrates scheduler + HTTP API - Handles graceful shutdown - Manages pulse execution lifecycle</p> <p>Executor (<code>executor.py</code>): - Launches Hapi sessions - Injects prompts + sticky notes - Reports success/failure</p> <p>HTTP API (<code>server.py</code>): - FastAPI endpoints for external triggers - Token-based authentication - JSON request/response</p> <p>Integration (<code>telegram.py</code>): - Polls Telegram API - POSTs to Pulse API - Simple, stateless design</p>"},{"location":"architecture/daemon-api/#next-steps","title":"Next Steps","text":"<p>See deployment.md for systemd setup, monitoring, and production deployment.</p>"},{"location":"architecture/deployment/","title":"Deployment Guide","text":""},{"location":"architecture/deployment/#overview","title":"Overview","text":"<p>This guide covers production deployment of the Pulse Daemon, including systemd service configuration, monitoring, logging, and troubleshooting.</p> <p>Quick Start: Use the automated installer for one-command setup with passwordless service management.</p>"},{"location":"architecture/deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux system with systemd (Ubuntu 20.04+, Debian 11+, or similar)</li> <li>Python 3.11+ installed</li> <li>uv package manager installed</li> <li>Non-root user account for running the service</li> </ul>"},{"location":"architecture/deployment/#installation","title":"Installation","text":""},{"location":"architecture/deployment/#1-clone-and-setup-repository","title":"1. Clone and Setup Repository","text":"<pre><code># Clone repository\ncd ~\ngit clone https://github.com/yourusername/reeve-bot.git\ncd reeve-bot\n\n# Install dependencies\nuv sync\n\n# Create necessary directories\nmkdir -p ~/.reeve/{logs,backups}\n\n# Initialize database\nuv run alembic upgrade head\n</code></pre>"},{"location":"architecture/deployment/#2-configure-environment","title":"2. Configure Environment","text":"<p>Create <code>.env</code> file in the repository root:</p> <pre><code># Copy template\ncp .env.example .env\n\n# Edit configuration\nnano .env\n</code></pre> <p>Environment Variables (<code>.env</code>):</p> <pre><code># Database\nPULSE_DB_PATH=~/.reeve/pulse_queue.db\n\n# Hapi\nHAPI_COMMAND=hapi\nREEVE_DESK_PATH=~/my_reeve\n\n# API\nPULSE_API_HOST=127.0.0.1\nPULSE_API_PORT=8765\nPULSE_API_TOKEN=your_secure_random_token_here\n\n# Executor\nPULSE_MAX_CONCURRENT=1                  # Max concurrent pulse execution (default: 1)\n\n# Telegram\nTELEGRAM_BOT_TOKEN=your_bot_token_here\nTELEGRAM_CHAT_ID=your_chat_id_here\n\n# Logging\nLOG_LEVEL=INFO\nLOG_FILE=~/.reeve/logs/daemon.log\n</code></pre> <p>Generate API Token: <pre><code>python3 -c \"import secrets; print(secrets.token_urlsafe(32))\"\n</code></pre></p>"},{"location":"architecture/deployment/#3-test-manual-execution","title":"3. Test Manual Execution","text":"<p>Before setting up systemd, verify the daemon runs correctly:</p> <pre><code># Start daemon\nuv run python -m reeve.pulse\n\n# In another terminal, test the API\ncurl http://localhost:8765/api/health\n\n# Trigger a test pulse\ncurl -X POST http://localhost:8765/api/pulse/trigger \\\n  -H \"Authorization: Bearer your_token_here\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"prompt\": \"Test pulse from curl\",\n    \"scheduled_at\": \"now\",\n    \"priority\": \"normal\",\n    \"source\": \"manual_test\"\n  }'\n\n# Check logs\ntail -f ~/.reeve/logs/daemon.log\n</code></pre> <p>Stop the daemon with <code>Ctrl+C</code> if it's working correctly.</p>"},{"location":"architecture/deployment/#automated-installation-recommended","title":"Automated Installation (Recommended)","text":""},{"location":"architecture/deployment/#using-the-installsh-script","title":"Using the install.sh Script","text":"<p>The recommended way to deploy Reeve is using the automated installer:</p> <pre><code># From the repository root\nsudo ./deploy/scripts/install.sh\n</code></pre> <p>What it installs: - \u2705 Systemd service files (<code>reeve-daemon.service</code>, <code>reeve-telegram.service</code>) - \u2705 Helper scripts (<code>reeve-status</code>, <code>reeve-logs</code>, <code>reeve-queue</code>, etc.) - \u2705 Sudoers configuration for passwordless service management - \u2705 Log rotation configuration - \u2705 Cron jobs (hourly heartbeat, credential keep-alive)</p> <p>Passwordless Service Management:</p> <p>After installation, all service management commands run without password prompts:</p> <pre><code># These work without entering a password:\nreeve-status                        # System health overview\nreeve-logs                          # View logs\nreeve-logs -n 50                    # Last 50 lines\nsudo systemctl restart reeve-daemon # Restart service\nsudo journalctl -u reeve-daemon -f  # Follow logs\n</code></pre> <p>The installer creates <code>/etc/sudoers.d/reeve</code> with an explicit allowlist for: - <code>systemctl status|start|stop|restart reeve-daemon|reeve-telegram</code> - <code>systemctl is-active|show reeve-daemon|reeve-telegram</code> - <code>journalctl -u reeve-daemon|reeve-telegram</code></p> <p>Security: Services run as your user (not root), so passwordless sudo doesn't create privilege escalation. See SECURITY.md for details.</p> <p>Uninstallation: <pre><code>sudo ./deploy/scripts/uninstall.sh       # Remove services and scripts\nsudo ./deploy/scripts/uninstall.sh --purge  # Also remove data directory\n</code></pre></p>"},{"location":"architecture/deployment/#manual-systemd-service-setup","title":"Manual Systemd Service Setup","text":""},{"location":"architecture/deployment/#1-create-service-file","title":"1. Create Service File","text":"<p>Create <code>/etc/systemd/system/reeve-daemon.service</code>:</p> <pre><code>[Unit]\nDescription=Reeve Pulse Daemon\nAfter=network.target\nWants=network-online.target\n\n[Service]\nType=simple\nUser=reuben\nGroup=reuben\nWorkingDirectory=/home/reuben/workspace/reeve-bot\n\n# Use uv to run the daemon\nExecStart=/home/reuben/.local/bin/uv run python -m reeve.pulse\n\n# Environment\nEnvironmentFile=/home/reuben/workspace/reeve-bot/.env\n\n# Restart policy\nRestart=always\nRestartSec=10\nStartLimitInterval=200\nStartLimitBurst=5\n\n# Logging (stdout/stderr \u2192 journald)\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=reeve-daemon\n\n# Security hardening\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=read-only\nReadWritePaths=/home/reuben/.reeve /home/reuben/my_reeve /home/reuben/.cache/uv /home/reuben/.hapi /home/reuben/.claude /home/reuben/.claude.json\n\n# Resource limits\nMemoryMax=2G\nCPUQuota=100%\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Notes: - Replace <code>/home/reuben/</code> with your actual home directory - Adjust <code>User</code> and <code>Group</code> to your username - <code>ReadWritePaths</code> allows daemon to write to required paths (database, desk, Claude Code config/credentials)</p>"},{"location":"architecture/deployment/#2-install-and-enable-service","title":"2. Install and Enable Service","text":"<pre><code># Copy service file (as root)\nsudo cp reeve-daemon.service /etc/systemd/system/\n\n# Reload systemd\nsudo systemctl daemon-reload\n\n# Enable service (start on boot)\nsudo systemctl enable reeve-daemon\n\n# Start service\nsudo systemctl start reeve-daemon\n\n# Check status\nsudo systemctl status reeve-daemon\n</code></pre>"},{"location":"architecture/deployment/#3-verify-service-is-running","title":"3. Verify Service is Running","text":"<pre><code># Check process\nps aux | grep \"reeve.pulse.daemon\"\n\n# Check logs (no password prompt if using install.sh)\nsudo journalctl -u reeve-daemon -f\n\n# Test API\ncurl http://localhost:8765/api/health\n</code></pre> <p>Note: If you used <code>install.sh</code>, <code>sudo</code> commands for reeve services won't prompt for a password.</p>"},{"location":"architecture/deployment/#telegram-listener-service","title":"Telegram Listener Service","text":"<p>The Telegram listener runs as a separate service that POSTs to the Pulse API.</p>"},{"location":"architecture/deployment/#1-create-service-file_1","title":"1. Create Service File","text":"<p>Create <code>/etc/systemd/system/reeve-telegram.service</code>:</p> <pre><code>[Unit]\nDescription=Reeve Telegram Listener\nAfter=network.target reeve-daemon.service\nWants=network-online.target\nRequires=reeve-daemon.service\n\n[Service]\nType=simple\nUser=reuben\nGroup=reuben\nWorkingDirectory=/home/reuben/workspace/reeve-bot\n\n# Run Telegram listener\nExecStart=/home/reuben/.local/bin/uv run python -m reeve.integrations.telegram\n\n# Environment\nEnvironmentFile=/home/reuben/workspace/reeve-bot/.env\n\n# Restart policy\nRestart=always\nRestartSec=10\n\n# Logging\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=reeve-telegram\n\n# Security\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"architecture/deployment/#2-install-and-enable","title":"2. Install and Enable","text":"<pre><code>sudo cp reeve-telegram.service /etc/systemd/system/\nsudo systemctl daemon-reload\nsudo systemctl enable reeve-telegram\nsudo systemctl start reeve-telegram\nsudo systemctl status reeve-telegram\n</code></pre>"},{"location":"architecture/deployment/#monitoring-logging","title":"Monitoring &amp; Logging","text":""},{"location":"architecture/deployment/#1-view-logs","title":"1. View Logs","text":"<p>Note: All <code>sudo journalctl</code> commands run without password prompt after <code>install.sh</code>.</p> <p>Daemon logs: <pre><code># Real-time\nsudo journalctl -u reeve-daemon -f\n\n# Last 100 lines\nsudo journalctl -u reeve-daemon -n 100\n\n# Since boot\nsudo journalctl -u reeve-daemon -b\n\n# Filter by priority (errors only)\nsudo journalctl -u reeve-daemon -p err\n\n# Export to file\nsudo journalctl -u reeve-daemon --since today &gt; reeve-daemon.log\n</code></pre></p> <p>Telegram listener logs: <pre><code>sudo journalctl -u reeve-telegram -f\n</code></pre></p> <p>Application log file (<code>~/.reeve/logs/daemon.log</code>): <pre><code>tail -f ~/.reeve/logs/daemon.log\n</code></pre></p>"},{"location":"architecture/deployment/#2-log-rotation","title":"2. Log Rotation","text":"<p>Create <code>/etc/logrotate.d/reeve</code>:</p> <pre><code>/home/reuben/.reeve/logs/*.log {\n    daily\n    rotate 14\n    compress\n    delaycompress\n    missingok\n    notifempty\n    create 0640 reuben reuben\n    sharedscripts\n    postrotate\n        systemctl reload reeve-daemon &gt; /dev/null 2&gt;&amp;1 || true\n    endscript\n}\n</code></pre>"},{"location":"architecture/deployment/#3-health-monitoring","title":"3. Health Monitoring","text":"<p>Simple health check script (<code>/usr/local/bin/reeve-health-check</code>):</p> <pre><code>#!/bin/bash\n\n# Check if daemon is running\nif ! systemctl is-active --quiet reeve-daemon; then\n    echo \"ERROR: reeve-daemon is not running\"\n    exit 1\nfi\n\n# Check API health\nif ! curl -s http://localhost:8765/api/health &gt; /dev/null; then\n    echo \"ERROR: API health check failed\"\n    exit 1\nfi\n\necho \"OK: All services healthy\"\nexit 0\n</code></pre> <p>Add to cron (check every 5 minutes):</p> <pre><code># Edit crontab\ncrontab -e\n\n# Add line:\n*/5 * * * * /usr/local/bin/reeve-health-check || echo \"Reeve health check failed\" | mail -s \"Reeve Alert\" your@email.com\n</code></pre>"},{"location":"architecture/deployment/#4-hourly-heartbeat","title":"4. Hourly Heartbeat","text":"<p>The hourly heartbeat is the core of Reeve's proactive behavior. Every hour, a cron job schedules a pulse that wakes Reeve to check calendar, tasks, and messages - without waiting to be asked.</p> <p>Heartbeat script (<code>/usr/local/bin/reeve-heartbeat</code>):</p> <p>The script varies the prompt based on time of day: - Morning (6-12): Focus on daily priorities, calendar review - Afternoon (12-18): Upcoming meetings, pending tasks - Evening (18-22): End-of-day wrap-up, remaining tasks - Night (22-6): Light check, defer non-urgent items</p> <p>Add to cron (every hour on the hour):</p> <pre><code>crontab -e\n\n# Add:\n0 * * * * /usr/local/bin/reeve-heartbeat &gt;&gt; ~/.reeve/logs/heartbeat.log 2&gt;&amp;1\n</code></pre> <p>Manual trigger: <pre><code>/usr/local/bin/reeve-heartbeat\n</code></pre></p>"},{"location":"architecture/deployment/#5-credential-keep-alive","title":"5. Credential Keep-Alive","text":"<p>The credential keep-alive prevents OAuth token expiry for services Reeve depends on. It uses a pluggable provider architecture - each credential type has its own provider script.</p> <p>Keep-alive script (<code>/usr/local/bin/reeve-credential-keepalive</code>):</p> <p>The script discovers provider scripts from <code>/usr/local/lib/reeve/credential-providers/</code>, checks each credential's health, and refreshes tokens that are close to expiring.</p> <p>Current providers: - claude-code: Refreshes Claude Code OAuth tokens from <code>~/.claude/.credentials.json</code>. Triggers refresh when the token expires within 6 hours.</p> <p>Add to cron (every 4 hours):</p> <pre><code>crontab -e\n\n# Add:\n0 */4 * * * /usr/local/bin/reeve-credential-keepalive &gt;&gt; ~/.reeve/logs/credential-keepalive.log 2&gt;&amp;1\n</code></pre> <p>Manual trigger: <pre><code>/usr/local/bin/reeve-credential-keepalive\n</code></pre></p>"},{"location":"architecture/deployment/#6-metrics-optional","title":"6. Metrics (Optional)","text":"<p>For production monitoring, consider:</p> <ul> <li>Prometheus + Grafana: Expose metrics endpoint in FastAPI</li> <li>Datadog/New Relic: APM integration</li> <li>Custom metrics: Track pulse execution rate, failures, duration</li> </ul> <p>Example Prometheus metrics: <pre><code># In api/server.py\nfrom prometheus_client import Counter, Histogram, generate_latest\n\npulses_executed = Counter('reeve_pulses_executed_total', 'Total pulses executed')\npulse_duration = Histogram('reeve_pulse_duration_seconds', 'Pulse execution duration')\n\n@app.get(\"/metrics\")\nasync def metrics():\n    return Response(generate_latest(), media_type=\"text/plain\")\n</code></pre></p>"},{"location":"architecture/deployment/#database-management","title":"Database Management","text":""},{"location":"architecture/deployment/#1-backups","title":"1. Backups","text":"<p>Automated backup script (<code>/usr/local/bin/reeve-backup</code>):</p> <pre><code>#!/bin/bash\n\nBACKUP_DIR=\"/home/reuben/.reeve/backups\"\nDB_PATH=\"/home/reuben/.reeve/pulse_queue.db\"\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\n\n# Create backup\nsqlite3 \"$DB_PATH\" \".backup $BACKUP_DIR/pulse_queue_$TIMESTAMP.db\"\n\n# Compress\ngzip \"$BACKUP_DIR/pulse_queue_$TIMESTAMP.db\"\n\n# Keep only last 30 days\nfind \"$BACKUP_DIR\" -name \"pulse_queue_*.db.gz\" -mtime +30 -delete\n\necho \"Backup completed: pulse_queue_$TIMESTAMP.db.gz\"\n</code></pre> <p>Add to cron (daily at 3 AM):</p> <pre><code>crontab -e\n\n# Add:\n0 3 * * * /usr/local/bin/reeve-backup\n</code></pre>"},{"location":"architecture/deployment/#2-database-migrations","title":"2. Database Migrations","text":"<p>When upgrading Reeve to a new version with schema changes:</p> <pre><code># Stop daemon\nsudo systemctl stop reeve-daemon\n\n# Backup database\n/usr/local/bin/reeve-backup\n\n# Run migrations\ncd ~/workspace/reeve-bot\nuv run alembic upgrade head\n\n# Start daemon\nsudo systemctl start reeve-daemon\n\n# Verify\nsudo systemctl status reeve-daemon\n</code></pre>"},{"location":"architecture/deployment/#3-database-inspection","title":"3. Database Inspection","text":"<pre><code># Open SQLite shell\nsqlite3 ~/.reeve/pulse_queue.db\n\n# Useful queries:\n.tables\n.schema pulses\n\nSELECT COUNT(*) FROM pulses WHERE status = 'pending';\nSELECT * FROM pulses ORDER BY scheduled_at DESC LIMIT 10;\nSELECT priority, COUNT(*) FROM pulses GROUP BY priority;\n\n# Exit\n.quit\n</code></pre>"},{"location":"architecture/deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/deployment/#problem-daemon-wont-start","title":"Problem: Daemon won't start","text":"<p>Check logs: <pre><code>sudo journalctl -u reeve-daemon -xe\n</code></pre></p> <p>Common issues:</p> <ol> <li>Database locked:    <pre><code>sqlite3.OperationalError: database is locked\n</code></pre></li> <li> <p>Solution: Kill any processes holding the DB lock    <pre><code>lsof ~/.reeve/pulse_queue.db\nkill &lt;PID&gt;\n</code></pre></p> </li> <li> <p>Missing dependencies:    <pre><code>ModuleNotFoundError: No module named 'reeve'\n</code></pre></p> </li> <li> <p>Solution: Reinstall dependencies    <pre><code>cd ~/workspace/reeve-bot\nuv sync\n</code></pre></p> </li> <li> <p>Permission denied:    <pre><code>PermissionError: [Errno 13] Permission denied: '/home/reuben/.reeve'\n</code></pre></p> </li> <li>Solution: Fix ownership    <pre><code>sudo chown -R reuben:reuben ~/.reeve\nchmod 755 ~/.reeve\n</code></pre></li> </ol>"},{"location":"architecture/deployment/#problem-api-not-responding","title":"Problem: API not responding","text":"<p>Check if port is bound: <pre><code>sudo netstat -tlnp | grep 8765\n</code></pre></p> <p>Test locally: <pre><code>curl -v http://localhost:8765/api/health\n</code></pre></p> <p>Check firewall: <pre><code>sudo ufw status\n# If blocked, allow:\nsudo ufw allow 8765/tcp\n</code></pre></p>"},{"location":"architecture/deployment/#problem-pulses-not-executing","title":"Problem: Pulses not executing","text":"<p>Check scheduler loop: <pre><code>sudo journalctl -u reeve-daemon | grep \"Executing pulse\"\n</code></pre></p> <p>Query database for stuck pulses: <pre><code>sqlite3 ~/.reeve/pulse_queue.db \"SELECT * FROM pulses WHERE status='processing' AND executed_at &lt; datetime('now', '-5 minutes');\"\n</code></pre></p> <p>Manually reset stuck pulses: <pre><code>UPDATE pulses SET status='pending' WHERE status='processing' AND executed_at &lt; datetime('now', '-10 minutes');\n</code></pre></p>"},{"location":"architecture/deployment/#problem-hapi-execution-fails","title":"Problem: Hapi execution fails","text":"<p>Check Hapi installation: <pre><code>which hapi\nhapi --version\n</code></pre></p> <p>Check Desk path: <pre><code>ls -la ~/my_reeve/\n</code></pre></p> <p>Test Hapi manually: <pre><code>cd ~/my_reeve\nhapi run --text \"Test prompt\"\n</code></pre></p>"},{"location":"architecture/deployment/#security-hardening","title":"Security Hardening","text":""},{"location":"architecture/deployment/#1-api-token-security","title":"1. API Token Security","text":"<p>Never commit <code>.env</code> to git: <pre><code># Verify .gitignore\ngrep \".env\" .gitignore\n</code></pre></p> <p>Rotate API token regularly: <pre><code># Generate new token\nNEW_TOKEN=$(python3 -c \"import secrets; print(secrets.token_urlsafe(32))\")\n\n# Update .env\nsed -i \"s/PULSE_API_TOKEN=.*/PULSE_API_TOKEN=$NEW_TOKEN/\" .env\n\n# Restart services\nsudo systemctl restart reeve-daemon reeve-telegram\n</code></pre></p>"},{"location":"architecture/deployment/#2-firewall-configuration","title":"2. Firewall Configuration","text":"<p>Allow only local connections (default): <pre><code># In .env\nPULSE_API_HOST=127.0.0.1  # Localhost only\n</code></pre></p> <p>If remote access needed: <pre><code># Bind to all interfaces\nPULSE_API_HOST=0.0.0.0\n\n# Configure firewall to allow only specific IPs\nsudo ufw allow from 192.168.1.0/24 to any port 8765\n</code></pre></p>"},{"location":"architecture/deployment/#3-tlshttps-optional","title":"3. TLS/HTTPS (Optional)","text":"<p>For remote access, use a reverse proxy (nginx) with TLS:</p> <pre><code># /etc/nginx/sites-available/reeve\nserver {\n    listen 443 ssl;\n    server_name reeve.yourdomain.com;\n\n    ssl_certificate /etc/letsencrypt/live/reeve.yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/reeve.yourdomain.com/privkey.pem;\n\n    location /api/ {\n        proxy_pass http://127.0.0.1:8765/api/;\n        proxy_set_header Authorization $http_authorization;\n    }\n}\n</code></pre>"},{"location":"architecture/deployment/#upgrading","title":"Upgrading","text":""},{"location":"architecture/deployment/#standard-upgrade-process","title":"Standard Upgrade Process","text":"<pre><code># 1. Stop services\nsudo systemctl stop reeve-telegram reeve-daemon\n\n# 2. Backup database\n/usr/local/bin/reeve-backup\n\n# 3. Pull latest code\ncd ~/workspace/reeve-bot\ngit pull origin main\n\n# 4. Update dependencies\nuv sync\n\n# 5. Run migrations\nuv run alembic upgrade head\n\n# 6. Restart services\nsudo systemctl start reeve-daemon reeve-telegram\n\n# 7. Verify\nsudo systemctl status reeve-daemon\ncurl http://localhost:8765/api/health\n</code></pre>"},{"location":"architecture/deployment/#rollback-procedure","title":"Rollback Procedure","text":"<p>If upgrade fails:</p> <pre><code># 1. Stop services\nsudo systemctl stop reeve-telegram reeve-daemon\n\n# 2. Revert code\ncd ~/workspace/reeve-bot\ngit checkout &lt;previous-commit&gt;\n\n# 3. Restore database\ncp ~/.reeve/backups/pulse_queue_TIMESTAMP.db.gz /tmp/\ngunzip /tmp/pulse_queue_TIMESTAMP.db.gz\ncp /tmp/pulse_queue_TIMESTAMP.db ~/.reeve/pulse_queue.db\n\n# 4. Restart\nsudo systemctl start reeve-daemon reeve-telegram\n</code></pre>"},{"location":"architecture/deployment/#performance-tuning","title":"Performance Tuning","text":""},{"location":"architecture/deployment/#database-optimization","title":"Database Optimization","text":"<p>Enable WAL mode (better concurrency): <pre><code>sqlite3 ~/.reeve/pulse_queue.db \"PRAGMA journal_mode=WAL;\"\n</code></pre></p> <p>Analyze and optimize: <pre><code>sqlite3 ~/.reeve/pulse_queue.db \"ANALYZE;\"\nsqlite3 ~/.reeve/pulse_queue.db \"VACUUM;\"\n</code></pre></p>"},{"location":"architecture/deployment/#resource-limits","title":"Resource Limits","text":"<p>Adjust systemd service limits:</p> <pre><code># In reeve-daemon.service\nMemoryMax=1G          # Increase if needed\nCPUQuota=100%         # Use full core\nLimitNOFILE=4096      # File descriptor limit\n</code></pre>"},{"location":"architecture/deployment/#concurrency-tuning","title":"Concurrency Tuning","text":"<p>Adjust daemon configuration:</p> <pre><code># In daemon.py _scheduler_loop()\npulses = await self.queue.get_due_pulses(limit=50)  # Process more at once\n</code></pre> <pre><code># Enable parallel execution\nfor pulse in pulses:\n    asyncio.create_task(self._execute_pulse(pulse))  # Don't await\n</code></pre>"},{"location":"architecture/deployment/#summary","title":"Summary","text":"<p>Production Checklist:</p> <ul> <li>\u2705 Daemon running as systemd service</li> <li>\u2705 Telegram listener as systemd service</li> <li>\u2705 Daily database backups</li> <li>\u2705 Log rotation configured</li> <li>\u2705 Health monitoring in place</li> <li>\u2705 Credential keep-alive configured</li> <li>\u2705 API token secured</li> <li>\u2705 Firewall configured</li> <li>\u2705 Upgrade/rollback procedure documented</li> </ul> <p>Monitoring Dashboard (to build): - Pulses executed/hour - Average execution time - Failure rate - Queue depth - API response time</p> <p>Your Pulse Queue system is now production-ready!</p>"},{"location":"architecture/mcp-integration/","title":"MCP Integration Design","text":""},{"location":"architecture/mcp-integration/#overview","title":"Overview","text":"<p>This document specifies the MCP (Model Context Protocol) servers that Reeve uses to interact with the Pulse Queue system and send notifications. These servers expose tools that Reeve can call directly from within Hapi/Claude Code sessions.</p>"},{"location":"architecture/mcp-integration/#mcp-server-1-pulse-queue-server","title":"MCP Server 1: Pulse Queue Server","text":"<p>Module: <code>src/reeve/mcp/pulse_server.py</code></p> <p>Purpose: Allow Reeve to manage its own schedule by creating, viewing, and modifying pulses.</p> <p>Connection Type: stdio (spawned on-demand by Reeve)</p>"},{"location":"architecture/mcp-integration/#implementation","title":"Implementation","text":"<pre><code>\"\"\"\nMCP Server for Pulse Queue Management\n\nThis server exposes tools that allow Reeve (Claude Code) to proactively manage\nits own scheduling. Reeve can set alarms, check its upcoming schedule, and\ncancel or reschedule tasks.\n\nUsage:\n    Configure in ~/.config/claude-code/mcp_config.json:\n    {\n      \"mcpServers\": {\n        \"pulse-queue\": {\n          \"command\": \"uv\",\n          \"args\": [\"run\", \"--directory\", \"/path/to/reeve-bot\", \"python\", \"-m\", \"reeve.mcp.pulse_server\"]\n        }\n      }\n    }\n\"\"\"\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import TextContent\nfrom pydantic import Field\nfrom typing import Annotated, Literal, Optional\nfrom datetime import datetime, timezone, timedelta\nfrom contextlib import asynccontextmanager\nimport os\n\nfrom reeve.pulse.queue import PulseQueue\nfrom reeve.pulse.enums import PulsePriority, PulseStatus\n\n# Initialize the MCP server\napp = Server(\"pulse-queue\")\n\n# Initialize the pulse queue (database connection)\nDB_PATH = os.getenv(\"PULSE_DB_PATH\", \"~/.reeve/pulse_queue.db\")\nqueue = PulseQueue(f\"sqlite+aiosqlite:///{os.path.expanduser(DB_PATH)}\")\n\n\n# ============================================================================\n# Tool Definitions\n# ============================================================================\n\n@app.tool()\nasync def schedule_pulse(\n    scheduled_at: Annotated[\n        str,\n        Field(\n            description=(\n                \"When to execute this pulse. Accepts multiple formats:\\n\"\n                \"- ISO 8601 timestamp: '2026-01-20T09:00:00Z'\\n\"\n                \"- Relative time: 'in 2 hours', 'in 30 minutes', 'tomorrow at 9am'\\n\"\n                \"- Special keywords: 'now' (immediate), 'tonight' (today at 10pm), 'tomorrow morning' (tomorrow at 8am)\\n\\n\"\n                \"IMPORTANT: All times are interpreted in the user's local timezone unless a UTC 'Z' suffix is provided.\"\n            ),\n            examples=[\"2026-01-20T09:00:00Z\", \"in 2 hours\", \"tomorrow at 9am\", \"now\"]\n        )\n    ],\n    prompt: Annotated[\n        str,\n        Field(\n            description=(\n                \"The instruction or context for Reeve when this pulse fires. \"\n                \"This becomes the initial message in the spawned Hapi session.\\n\\n\"\n                \"Be specific and action-oriented. Good examples:\\n\"\n                \"- 'Check flight status for UA123 and notify user if delayed'\\n\"\n                \"- 'Daily morning briefing: review calendar, check email, summarize priorities'\\n\"\n                \"- 'Follow up: Did user reply to the snowboarding trip proposal?'\\n\\n\"\n                \"Avoid vague prompts like 'check things' or 'do stuff'.\"\n            ),\n            min_length=10,\n            max_length=2000\n        )\n    ],\n    priority: Annotated[\n        Literal[\"critical\", \"high\", \"normal\", \"low\", \"deferred\"],\n        Field(\n            description=(\n                \"Urgency level for this pulse. Determines execution order when multiple pulses are due:\\n\\n\"\n                \"- 'critical' (\ud83d\udea8): Emergencies, user messages, system failures. Interrupts deep work.\\n\"\n                \"- 'high' (\ud83d\udd14): Important external events, user-facing tasks, scheduled alarms.\\n\"\n                \"- 'normal' (\u23f0): Regular maintenance, periodic checks, calendar reminders. (DEFAULT)\\n\"\n                \"- 'low' (\ud83d\udccb): Background tasks, cleanup, non-urgent maintenance.\\n\"\n                \"- 'deferred' (\ud83d\udd50): Intentionally postponed tasks, snoozed items.\\n\\n\"\n                \"Default: 'normal'\"\n            ),\n        )\n    ] = \"normal\",\n    resume_in_current_session: Annotated[\n        bool,\n        Field(\n            description=(\n                \"Whether to resume the pulse in the current session (default: False).\\n\\n\"\n                \"- False (default): The pulse starts a brand new session. Recommended for most use cases.\\n\"\n                \"- True: The pulse resumes in the current session, injecting the prompt as if it were a new user message at the scheduled time.\\n\\n\"\n                \"WARNING: Setting this to True means the prompt will be injected into the current session context. \"\n                \"This is useful when there's rich context to preserve, but be careful - if the user advances the conversation, \"\n                \"the pulse prompt might not be relevant anymore.\"\n            ),\n        )\n    ] = False,\n    sticky_notes: Annotated[\n        Optional[list[str]],\n        Field(\n            description=(\n                \"Optional list of reminder strings to inject into the prompt when the pulse fires. \"\n                \"Use this to carry forward context between pulses.\\n\\n\"\n                \"Examples:\\n\"\n                \"- ['User asked about snowboarding trip on Monday', 'Check if anyone replied in group chat']\\n\"\n                \"- ['Flight departs at 6:45 AM', 'TSA PreCheck lane available']\\n\\n\"\n                \"These will be prepended to the main prompt with clear formatting.\"\n            ),\n        )\n    ] = None,\n    tags: Annotated[\n        Optional[list[str]],\n        Field(\n            description=(\n                \"Optional categorization tags for filtering and organization. \"\n                \"Useful for querying related pulses or understanding patterns.\\n\\n\"\n                \"Examples: ['daily', 'morning_routine'], ['trip_planning', 'japan'], ['follow_up', 'github']\"\n            ),\n        )\n    ] = None,\n) -&gt; str:\n    \"\"\"\n    Schedule a new pulse (wake-up event) for Reeve.\n\n    This is Reeve's primary tool for proactive behavior. Use this to schedule\n    future tasks, set reminders, or create follow-up checks.\n\n    When to use:\n    - Set alarms: \"Remind me to check ticket prices tomorrow at 8am\"\n    - Schedule follow-ups: \"Check if user replied in 2 hours\"\n    - Create recurring checks: \"Every morning at 9am, review calendar\"\n    - Defer tasks: \"I can't handle this now, wake me up tonight to finish\"\n\n    When NOT to use:\n    - Immediate actions (just do them now)\n    - One-time informational tasks (use memory/notes instead)\n\n    Examples:\n        # Set a morning briefing\n        schedule_pulse(\n            scheduled_at=\"tomorrow at 9am\",\n            prompt=\"Daily morning briefing: review calendar, check email, summarize priorities\",\n            priority=\"normal\",\n            tags=[\"daily\", \"morning_routine\"]\n        )\n\n        # Follow up on a pending task\n        schedule_pulse(\n            scheduled_at=\"in 2 hours\",\n            prompt=\"Check if user replied to the snowboarding trip proposal in group chat\",\n            priority=\"high\",\n            sticky_notes=[\"Sent message at 2:30 PM\", \"Waiting for Alex and Jamie to confirm\"],\n            tags=[\"follow_up\", \"social\"]\n        )\n\n        # Critical pre-departure check\n        schedule_pulse(\n            scheduled_at=\"2026-01-20T06:00:00Z\",\n            prompt=\"Check flight status for UA123 and notify user immediately if delayed\",\n            priority=\"critical\",\n            tags=[\"travel\", \"urgent\"]\n        )\n\n    Returns:\n        Confirmation message with the pulse ID and scheduled time\n    \"\"\"\n    # Parse scheduled_at (handle relative times, keywords, etc.)\n    parsed_time = _parse_time_string(scheduled_at)\n\n    # Determine session ID based on resume_in_current_session\n    session_id = None\n    if resume_in_current_session:\n        try:\n            session_id = ctx.session_id\n        except (RuntimeError, AttributeError):\n            # Session ID not available - fall back to new session\n            pass\n\n    # Create the pulse\n    pulse_id = await queue.schedule_pulse(\n        scheduled_at=parsed_time,\n        prompt=prompt,\n        priority=PulsePriority(priority),\n        session_id=session_id,\n        sticky_notes=sticky_notes,\n        tags=tags,\n        created_by=\"reeve\",\n    )\n\n    # Format response\n    time_str = parsed_time.strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n    return (\n        f\"\u2713 Pulse scheduled successfully\\n\\n\"\n        f\"Pulse ID: {pulse_id}\\n\"\n        f\"Scheduled: {time_str}\\n\"\n        f\"Priority: {priority} {_priority_emoji(priority)}\\n\"\n        f\"Prompt: {prompt[:100]}{'...' if len(prompt) &gt; 100 else ''}\"\n    )\n\n\n@app.tool()\nasync def list_upcoming_pulses(\n    limit: Annotated[\n        int,\n        Field(\n            description=\"Maximum number of pulses to return (default: 20, max: 100)\",\n            ge=1,\n            le=100\n        )\n    ] = 20,\n    include_completed: Annotated[\n        bool,\n        Field(\n            description=\"Whether to include recently completed pulses (default: False, only show pending)\"\n        )\n    ] = False,\n) -&gt; str:\n    \"\"\"\n    List upcoming scheduled pulses.\n\n    Use this to check Reeve's schedule and understand what tasks are coming up.\n    Useful for:\n    - Seeing what's on the agenda\n    - Verifying a pulse was scheduled correctly\n    - Detecting scheduling conflicts\n    - Understanding workload distribution\n\n    Examples:\n        # Check what's coming up\n        list_upcoming_pulses(limit=10)\n\n        # Review recent history\n        list_upcoming_pulses(limit=20, include_completed=True)\n\n    Returns:\n        Formatted list of pulses with time, priority, and prompt preview\n    \"\"\"\n    statuses = [PulseStatus.PENDING]\n    if include_completed:\n        statuses.extend([PulseStatus.COMPLETED, PulseStatus.PROCESSING])\n\n    pulses = await queue.get_upcoming_pulses(limit=limit, include_statuses=statuses)\n\n    if not pulses:\n        return \"No upcoming pulses scheduled. The schedule is clear.\"\n\n    # Format as a table\n    lines = [\"Upcoming Pulses:\\n\"]\n    now = datetime.now(timezone.utc)\n\n    for pulse in pulses:\n        # Calculate time until pulse\n        time_delta = pulse.scheduled_at - now\n        if time_delta.total_seconds() &lt; 0:\n            time_str = \"OVERDUE\"\n        elif time_delta.total_seconds() &lt; 3600:\n            time_str = f\"in {int(time_delta.total_seconds() / 60)}m\"\n        elif time_delta.total_seconds() &lt; 86400:\n            time_str = f\"in {int(time_delta.total_seconds() / 3600)}h\"\n        else:\n            time_str = pulse.scheduled_at.strftime(\"%b %d %H:%M\")\n\n        emoji = _priority_emoji(pulse.priority.value)\n        status_emoji = _status_emoji(pulse.status.value)\n        prompt_preview = pulse.prompt[:60] + \"...\" if len(pulse.prompt) &gt; 60 else pulse.prompt\n\n        lines.append(\n            f\"{status_emoji} [{pulse.id:04d}] {emoji} {time_str:12s} | {prompt_preview}\"\n        )\n\n    return \"\\n\".join(lines)\n\n\n@app.tool()\nasync def cancel_pulse(\n    pulse_id: Annotated[\n        int,\n        Field(\n            description=\"The ID of the pulse to cancel (from list_upcoming_pulses)\",\n            gt=0\n        )\n    ],\n) -&gt; str:\n    \"\"\"\n    Cancel a scheduled pulse.\n\n    Use this when a task is no longer needed or circumstances have changed.\n\n    Examples:\n        # User already handled the task manually\n        cancel_pulse(pulse_id=42)\n\n        # Event was cancelled\n        cancel_pulse(pulse_id=123)\n\n    Returns:\n        Confirmation message or error if pulse couldn't be cancelled\n    \"\"\"\n    success = await queue.cancel_pulse(pulse_id)\n\n    if success:\n        return f\"\u2713 Pulse {pulse_id} cancelled successfully\"\n    else:\n        return f\"\u2717 Could not cancel pulse {pulse_id} (may be already completed or not found)\"\n\n\n@app.tool()\nasync def reschedule_pulse(\n    pulse_id: Annotated[\n        int,\n        Field(\n            description=\"The ID of the pulse to reschedule (from list_upcoming_pulses)\",\n            gt=0\n        )\n    ],\n    new_scheduled_at: Annotated[\n        str,\n        Field(\n            description=(\n                \"New execution time. Accepts same formats as schedule_pulse:\\n\"\n                \"- ISO 8601: '2026-01-20T09:00:00Z'\\n\"\n                \"- Relative: 'in 2 hours', 'tomorrow at 9am'\\n\"\n                \"- Keywords: 'tonight', 'tomorrow morning'\"\n            ),\n            examples=[\"in 2 hours\", \"tomorrow at 9am\", \"2026-01-20T15:00:00Z\"]\n        )\n    ],\n) -&gt; str:\n    \"\"\"\n    Reschedule a pulse to a different time.\n\n    Use this when timing needs to change but the task itself remains relevant.\n\n    Examples:\n        # Postpone to tomorrow\n        reschedule_pulse(pulse_id=42, new_scheduled_at=\"tomorrow at 9am\")\n\n        # Move earlier\n        reschedule_pulse(pulse_id=123, new_scheduled_at=\"in 30 minutes\")\n\n    Returns:\n        Confirmation message with old and new times\n    \"\"\"\n    parsed_time = _parse_time_string(new_scheduled_at)\n    success = await queue.reschedule_pulse(pulse_id, parsed_time)\n\n    if success:\n        time_str = parsed_time.strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n        return f\"\u2713 Pulse {pulse_id} rescheduled to {time_str}\"\n    else:\n        return f\"\u2717 Could not reschedule pulse {pulse_id} (may be already completed or not found)\"\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef _parse_time_string(time_str: str) -&gt; datetime:\n    \"\"\"\n    Parse a flexible time string into a UTC datetime.\n\n    Supports:\n    - ISO 8601: \"2026-01-20T09:00:00Z\"\n    - Relative: \"in 2 hours\", \"in 30 minutes\"\n    - Keywords: \"now\", \"tonight\", \"tomorrow morning\"\n\n    TODO: Integrate with a proper NLP library (dateparser, parsedatetime)\n    For now, implement basic cases.\n    \"\"\"\n    time_str = time_str.strip().lower()\n\n    # Keyword: \"now\"\n    if time_str == \"now\":\n        return datetime.now(timezone.utc)\n\n    # ISO 8601\n    if \"T\" in time_str or time_str.endswith(\"Z\"):\n        return datetime.fromisoformat(time_str.replace(\"Z\", \"+00:00\"))\n\n    # Relative: \"in X hours/minutes\"\n    if time_str.startswith(\"in \"):\n        parts = time_str[3:].split()\n        if len(parts) == 2:\n            amount = int(parts[0])\n            unit = parts[1].rstrip(\"s\")  # \"hours\" -&gt; \"hour\"\n\n            if unit == \"minute\":\n                return datetime.now(timezone.utc) + timedelta(minutes=amount)\n            elif unit == \"hour\":\n                return datetime.now(timezone.utc) + timedelta(hours=amount)\n            elif unit == \"day\":\n                return datetime.now(timezone.utc) + timedelta(days=amount)\n\n    # Fallback: raise error for unimplemented formats\n    raise ValueError(\n        f\"Could not parse time string: '{time_str}'. \"\n        f\"Supported formats: ISO 8601, 'now', 'in X hours/minutes/days'\"\n    )\n\n\ndef _priority_emoji(priority: str) -&gt; str:\n    \"\"\"Map priority to emoji for visual scanning.\"\"\"\n    return {\n        \"critical\": \"\ud83d\udea8\",\n        \"high\": \"\ud83d\udd14\",\n        \"normal\": \"\u23f0\",\n        \"low\": \"\ud83d\udccb\",\n        \"deferred\": \"\ud83d\udd50\",\n    }.get(priority, \"\")\n\n\ndef _status_emoji(status: str) -&gt; str:\n    \"\"\"Map status to emoji for visual scanning.\"\"\"\n    return {\n        \"pending\": \"\u23f3\",\n        \"processing\": \"\u2699\ufe0f\",\n        \"completed\": \"\u2705\",\n        \"failed\": \"\u274c\",\n        \"cancelled\": \"\ud83d\udeab\",\n    }.get(status, \"\")\n\n\n# ============================================================================\n# Server Entry Point\n# ============================================================================\n\nasync def main():\n    \"\"\"Run the MCP server on stdio.\"\"\"\n    async with stdio_server() as (read_stream, write_stream):\n        await app.run(\n            read_stream,\n            write_stream,\n            app.create_initialization_options()\n        )\n\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"architecture/mcp-integration/#mcp-server-2-telegram-notification-server","title":"MCP Server 2: Telegram Notification Server","text":"<p>Module: <code>src/reeve/mcp/notification_server.py</code></p> <p>Purpose: Allow Reeve to send push notifications to the user via Telegram.</p> <p>Connection Type: stdio (spawned on-demand by Reeve)</p>"},{"location":"architecture/mcp-integration/#implementation_1","title":"Implementation","text":"<pre><code>\"\"\"\nMCP Server for Telegram Notifications\n\nThis server exposes tools that allow Reeve to send push notifications to the\nuser via Telegram. This is Reeve's \"voice\" - how it communicates proactively.\n\nEnvironment Variables:\n    TELEGRAM_BOT_TOKEN: Telegram bot token (required)\n    TELEGRAM_CHAT_ID: User's Telegram chat ID (required)\n    HAPI_BASE_URL: Base URL for Hapi sessions (optional, defaults to https://hapi.run)\n\nUsage:\n    Configure in ~/.config/claude-code/mcp_config.json:\n    {\n      \"mcpServers\": {\n        \"telegram-notifier\": {\n          \"command\": \"uv\",\n          \"args\": [\"run\", \"--directory\", \"/path/to/reeve-bot\", \"python\", \"-m\", \"reeve.mcp.notification_server\"],\n          \"env\": {\n            \"TELEGRAM_BOT_TOKEN\": \"your_bot_token\",\n            \"TELEGRAM_CHAT_ID\": \"your_chat_id\",\n            \"HAPI_BASE_URL\": \"https://hapi.run\"\n          }\n        }\n      }\n    }\n\"\"\"\n\nimport os\nfrom typing import Annotated, Literal\n\nimport requests\nfrom mcp.server.fastmcp import FastMCP, Context\nfrom pydantic import Field\n\n# Initialize the MCP server\nmcp = FastMCP(\"telegram-notifier\")\n\n# Telegram Bot Configuration\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")\nCHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")  # The user's chat ID\nHAPI_BASE_URL = os.getenv(\"HAPI_BASE_URL\", \"https://hapi.run\")\n\nif not BOT_TOKEN or not CHAT_ID:\n    raise ValueError(\"TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID environment variables are required\")\n\n\n# ============================================================================\n# Tool Definitions\n# ============================================================================\n\n@mcp.tool()\nasync def send_notification(\n    ctx: Context,\n    message: Annotated[\n        str,\n        Field(\n            description=(\n                \"The notification message to send (up to 4096 characters). \"\n                \"Keep it concise and actionable - this is a push notification.\\n\\n\"\n                \"Good examples:\\n\"\n                \"- '\ud83d\udd14 Powder Alert: 18 inches forecast for Mammoth this weekend'\\n\"\n                \"- '\u2713 Daily briefing complete. 3 meetings today, 2 high-priority emails.'\\n\"\n                \"- '\ud83d\udea8 Flight UA123 delayed 2 hours. New departure: 10:30 AM'\\n\\n\"\n                \"If parse_mode is set, you can use formatting:\\n\"\n                \"- MarkdownV2: *bold*, _italic_, `code`, [link](url)\\n\"\n                \"- HTML: &lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt;, &lt;code&gt;code&lt;/code&gt;, &lt;a href='url'&gt;link&lt;/a&gt;\"\n            ),\n            min_length=1,\n            max_length=4096,\n        ),\n    ],\n    priority: Annotated[\n        Literal[\"silent\", \"normal\", \"critical\"],\n        Field(\n            description=(\n                \"Notification priority level:\\n\"\n                \"- 'silent' (\ud83d\udd15): No alert, just logs to chat (no sound/vibration)\\n\"\n                \"- 'normal' (\ud83d\udd14): Standard push notification with sound (default)\\n\"\n                \"- 'critical' (\ud83d\udea8): High-priority alert with sound\\n\\n\"\n                \"This controls both notification behavior and routing.\"\n            ),\n        ),\n    ] = \"normal\",\n    parse_mode: Annotated[\n        Literal[\"MarkdownV2\", \"HTML\", \"Markdown\"] | None,\n        Field(\n            description=(\n                \"Optional message formatting mode:\\n\"\n                \"- 'MarkdownV2': Markdown formatting (recommended) - *bold*, _italic_, `code`\\n\"\n                \"- 'HTML': HTML formatting - &lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt;, &lt;code&gt;code&lt;/code&gt;\\n\"\n                \"- 'Markdown': Legacy Markdown (deprecated, use MarkdownV2)\\n\"\n                \"- None: Plain text (default)\\n\\n\"\n                \"Use MarkdownV2 for rich notifications, None for simple alerts.\"\n            ),\n        ),\n    ] = None,\n) -&gt; str:\n    \"\"\"\n    Send a push notification to the user via Telegram.\n\n    This is Reeve's primary communication channel with the user. Use this to:\n    - Alert about important events (flight delays, weather alerts, etc.)\n    - Provide task completion updates\n    - Request user input or decisions\n    - Share summaries and insights\n\n    The tool automatically includes a \"View in Claude Code\" button linking to the current\n    session, so the user can quickly jump back to the conversation context.\n\n    Priority levels control notification behavior:\n    - silent: No sound/vibration (for background updates)\n    - normal: Standard notification with sound (default)\n    - critical: High-priority alert with sound\n\n    When to use:\n    - Proactive alerts: \"Something happened you should know about\"\n    - Task updates: \"I finished X, here's the result\"\n    - Requests: \"I need your input on Y\"\n\n    When NOT to use:\n    - Responding to user messages (they're already in the chat)\n    - Logging/debugging (use internal logs instead)\n    - High-frequency updates (batch them into summaries)\n\n    Examples:\n        # Simple alert with auto-generated Claude Code link\n        send_notification(\n            message=\"\u2713 Daily briefing complete. 3 meetings today.\"\n        )\n\n        # Formatted urgent alert\n        send_notification(\n            message=\"*URGENT*: Flight UA123 delayed 2 hours\\\\nNew departure: 10:30 AM\",\n            parse_mode=\"MarkdownV2\",\n            priority=\"critical\"\n        )\n\n        # Silent background update\n        send_notification(\n            message=\"\ud83d\udccb Archived 47 old notes to Diary/2026-01/\",\n            priority=\"silent\"\n        )\n\n    Returns:\n        Confirmation message or error details\n    \"\"\"\n    try:\n        # Determine notification sound based on priority\n        disable_notification = priority == \"silent\"\n\n        # Auto-generate Hapi URL from session ID\n        session_link_url = None\n        try:\n            session_id = ctx.session_id\n            session_link_url = f\"{HAPI_BASE_URL}/sessions/{session_id}\"\n        except (RuntimeError, AttributeError):\n            # Session ID not available - no link button\n            pass\n\n        # Send via Telegram Bot API\n        url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n        payload = {\n            \"chat_id\": CHAT_ID,\n            \"text\": message,\n            \"disable_notification\": disable_notification,\n        }\n\n        if parse_mode:\n            payload[\"parse_mode\"] = parse_mode\n\n        # Add session link button if available\n        if session_link_url:\n            reply_markup = {\n                \"inline_keyboard\": [[{\"text\": \"View in Claude Code\", \"url\": session_link_url}]]\n            }\n            payload[\"reply_markup\"] = reply_markup\n\n        response = requests.post(url, json=payload, timeout=10)\n        response.raise_for_status()\n\n        link_info = \" with link\" if session_link_url else \"\"\n        return f\"\u2713 Notification{link_info} sent successfully ({priority})\"\n\n    except requests.exceptions.RequestException as e:\n        return f\"\u2717 Failed to send notification: {str(e)}\"\n\n\n# ============================================================================\n# Server Entry Point\n# ============================================================================\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"architecture/mcp-integration/#configuration","title":"Configuration","text":""},{"location":"architecture/mcp-integration/#mcp-client-configuration","title":"MCP Client Configuration","text":"<p>Add to <code>~/.config/claude-code/mcp_config.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"pulse-queue\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--directory\",\n        \"/home/reuben/workspace/reeve-bot\",\n        \"python\",\n        \"-m\",\n        \"reeve.mcp.pulse_server\"\n      ],\n      \"env\": {\n        \"PULSE_DB_PATH\": \"/home/reuben/.reeve/pulse_queue.db\"\n      }\n    },\n    \"telegram-notifier\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--directory\",\n        \"/home/reuben/workspace/reeve-bot\",\n        \"python\",\n        \"-m\",\n        \"reeve.mcp.notification_server\"\n      ],\n      \"env\": {\n        \"TELEGRAM_BOT_TOKEN\": \"your_bot_token_here\",\n        \"TELEGRAM_CHAT_ID\": \"your_chat_id_here\",\n        \"HAPI_BASE_URL\": \"https://hapi.run\"\n      }\n    }\n  }\n}\n</code></pre> <p>Security Note: The bot token is sensitive. Consider using a secrets manager or environment variable injection instead of hardcoding in the config.</p>"},{"location":"architecture/mcp-integration/#environment-variables","title":"Environment Variables","text":"<p>Required: - <code>TELEGRAM_BOT_TOKEN</code>: Bot API token from @BotFather - <code>TELEGRAM_CHAT_ID</code>: User's chat ID (get from /start message)</p> <p>Optional: - <code>PULSE_DB_PATH</code>: Path to SQLite database (default: <code>~/.reeve/pulse_queue.db</code>) - <code>HAPI_BASE_URL</code>: Base URL for Hapi sessions (default: <code>https://hapi.run</code>)</p>"},{"location":"architecture/mcp-integration/#design-principles","title":"Design Principles","text":""},{"location":"architecture/mcp-integration/#1-type-safety-with-pydantic","title":"1. Type Safety with Pydantic","text":"<p>All tool parameters use <code>Annotated[Type, Field(...)]</code> to provide: - Runtime validation (Pydantic) - IDE autocomplete - Auto-generated MCP documentation - Clear error messages</p>"},{"location":"architecture/mcp-integration/#2-comprehensive-documentation","title":"2. Comprehensive Documentation","text":"<p>Each tool has: - Docstring: High-level purpose and usage - Field descriptions: Detailed parameter explanations - Examples: Concrete use cases - When to use / When NOT to use: Decision guidance</p> <p>This helps Reeve (Claude) make intelligent decisions about when to call tools.</p>"},{"location":"architecture/mcp-integration/#3-user-friendly-formatting","title":"3. User-Friendly Formatting","text":"<ul> <li>Emojis: Visual priority/status indicators</li> <li>Relative times: \"in 2 hours\" vs. ISO timestamps</li> <li>Concise output: Essential info only, no clutter</li> </ul>"},{"location":"architecture/mcp-integration/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Graceful failures: Return error strings, don't raise exceptions</li> <li>Actionable messages: \"Could not cancel pulse (not found)\" vs. \"Error 404\"</li> <li>Success confirmation: Always confirm what happened</li> </ul>"},{"location":"architecture/mcp-integration/#testing-mcp-tools","title":"Testing MCP Tools","text":""},{"location":"architecture/mcp-integration/#manual-testing","title":"Manual Testing","text":"<pre><code># Terminal 1: Start MCP server\nuv run python -m reeve.mcp.pulse_server\n\n# Terminal 2: Send test input (MCP JSON-RPC protocol)\necho '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"schedule_pulse\",\n    \"arguments\": {\n      \"scheduled_at\": \"in 5 minutes\",\n      \"prompt\": \"Test pulse\",\n      \"priority\": \"normal\"\n    }\n  }\n}' | uv run python -m reeve.mcp.pulse_server\n</code></pre>"},{"location":"architecture/mcp-integration/#integration-testing","title":"Integration Testing","text":"<p>Use the Hapi/Claude Code test environment to call tools and verify behavior.</p>"},{"location":"architecture/mcp-integration/#next-steps","title":"Next Steps","text":"<p>See deployment.md for production deployment, systemd configuration, and monitoring setup.</p>"},{"location":"architecture/project-structure/","title":"Project Structure","text":""},{"location":"architecture/project-structure/#overview","title":"Overview","text":"<p>The <code>reeve-bot</code> repository contains the Engine component of Project Reeve - the immutable logic and infrastructure that powers the proactive \"Chief of Staff\" system. This is separate from the user's personal context (the \"Desk\"), which lives in a separate <code>my_reeve/</code> repository.</p>"},{"location":"architecture/project-structure/#directory-structure","title":"Directory Structure","text":"<pre><code>reeve-bot/\n\u251c\u2500\u2500 docs/                           # Architecture and implementation documentation\n\u2502   \u251c\u2500\u2500 architecture/              # Architecture documents\n\u2502   \u2502   \u251c\u2500\u2500 project-structure.md   # This file\n\u2502   \u2502   \u251c\u2500\u2500 pulse-queue.md         # Pulse queue architecture\n\u2502   \u2502   \u251c\u2500\u2500 mcp-integration.md     # MCP server specifications\n\u2502   \u2502   \u251c\u2500\u2500 daemon-api.md          # Daemon and API design\n\u2502   \u2502   \u2514\u2500\u2500 deployment.md          # Deployment and operations guide\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 reeve/                      # Main package\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 pulse/                  # Pulse Queue System\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 daemon.py          # Main daemon process\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 queue.py           # Queue management (SQLAlchemy)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 models.py          # Database models\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 executor.py        # Pulse execution logic (Hapi launcher)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 enums.py           # Priority, Status enums\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 mcp/                    # MCP Servers\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pulse_server.py    # Pulse Queue MCP Server\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 notification_server.py  # Telegram Notification MCP Server\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 integrations/           # External integration listeners\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 telegram.py        # Telegram bot listener\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 email.py           # Gmail listener (future)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 whatsapp.py        # WhatsApp listener (future)\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500 api/                    # HTTP REST API\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 server.py          # FastAPI/aiohttp server\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 routes.py          # Pulse trigger endpoints\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 utils/                  # Shared utilities\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u251c\u2500\u2500 config.py          # Configuration management\n\u2502   \u2502       \u2514\u2500\u2500 logging.py         # Logging setup\n\u2502   \u2502\n\u251c\u2500\u2500 cli/                            # Command-line tools\n\u2502   \u251c\u2500\u2500 pulse.py                   # `pulse` CLI tool for queue management\n\u2502   \u2514\u2500\u2500 reeve-daemon.py            # Daemon launcher\n\u2502\n\u251c\u2500\u2500 telegram_prototype/             # Original prototype (deprecated after migration)\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 tests/                          # Test suite\n\u2502   \u251c\u2500\u2500 test_pulse_queue.py\n\u2502   \u251c\u2500\u2500 test_mcp_server.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502\n\u251c\u2500\u2500 pyproject.toml                 # Main project configuration (uv-managed)\n\u251c\u2500\u2500 uv.lock                        # Dependency lock file\n\u251c\u2500\u2500 .python-version                # Python version (3.11)\n\u251c\u2500\u2500 .env.example                   # Environment variable template\n\u2514\u2500\u2500 README.md                      # Project documentation\n</code></pre>"},{"location":"architecture/project-structure/#package-design-principles","title":"Package Design Principles","text":""},{"location":"architecture/project-structure/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<ul> <li><code>pulse/</code>: Pure business logic for queue management (no I/O concerns)</li> <li><code>mcp/</code>: MCP protocol adapters (Reeve \u2194 Pulse Queue)</li> <li><code>api/</code>: HTTP REST adapters (External Systems \u2194 Pulse Queue)</li> <li><code>integrations/</code>: Event listeners that POST to API or Pulse Queue directly</li> <li><code>cli/</code>: User-facing command-line tools</li> </ul>"},{"location":"architecture/project-structure/#2-dependency-flow","title":"2. Dependency Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Reeve     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 MCP Server  \u2502\n\u2502  (Claude)   \u2502  stdio  \u2502 (pulse_*)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Telegram   \u2502\u2500HTTP\u2500\u2500\u25ba \u2502  HTTP API   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 Pulse Queue \u2502\n\u2502  Listener   \u2502         \u2502  (FastAPI)  \u2502         \u2502  (Core)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                       \u2502\n                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   SQLite    \u2502\n                        \u2502  (via ORM)  \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/project-structure/#3-configuration-strategy","title":"3. Configuration Strategy","text":"<p>Environment Variables (<code>.env</code> file): - <code>REEVE_DESK_PATH</code>: Path to user's Desk repository (e.g., <code>~/my_reeve/</code>) - <code>PULSE_DB_PATH</code>: Path to SQLite database (default: <code>$REEVE_DESK_PATH/.reeve/pulse_queue.db</code>) - <code>PULSE_API_PORT</code>: HTTP API port (default: <code>8765</code>) - <code>PULSE_API_TOKEN</code>: Authentication token for HTTP API - <code>HAPI_COMMAND</code>: Path to Hapi executable (default: <code>hapi</code>)</p> <p>Why this approach: - Allows different deployments (local dev, production, testing) - User's Desk path is configurable (different users = different contexts) - API token provides security for external triggers</p>"},{"location":"architecture/project-structure/#4-database-strategy","title":"4. Database Strategy","text":"<p>SQLAlchemy + SQLite: - Development/Production: Single-user system, SQLite is perfect - Alembic Migrations: Version-controlled schema changes - Why not Postgres?: Overkill for single-user, adds deployment complexity - Future: If multi-user, swap to Postgres with minimal code changes (ORM abstraction)</p>"},{"location":"architecture/project-structure/#5-execution-model","title":"5. Execution Model","text":"<p>Long-Running Daemon: - Single Python process running via systemd/supervisor - Asyncio event loop for concurrency - Runs multiple services in parallel:   1. Pulse scheduler loop (checks queue every 1 second)   2. MCP server (stdio, spawned by Reeve on-demand)   3. HTTP API server (persistent, for external events)</p>"},{"location":"architecture/project-structure/#6-mcp-server-design","title":"6. MCP Server Design","text":"<p>Two MCP Servers:</p> <ol> <li><code>pulse-queue</code> MCP Server (src/reeve/mcp/pulse_server.py):</li> <li>Tools: <code>schedule_pulse</code>, <code>list_upcoming_pulses</code>, <code>cancel_pulse</code>, <code>reschedule_pulse</code></li> <li> <p>Used by: Reeve (primary interface)</p> </li> <li> <p><code>telegram-notifier</code> MCP Server (src/reeve/mcp/notification_server.py):</p> </li> <li>Tools: <code>send_notification</code> (auto-generates session links)</li> <li>Used by: Reeve (to push notifications to user)</li> </ol> <p>Why separate servers? - Logical separation (scheduling vs. output) - Can be deployed independently - Different security scopes</p>"},{"location":"architecture/project-structure/#integration-points","title":"Integration Points","text":""},{"location":"architecture/project-structure/#1-reeve-hapiclaude-code","title":"1. Reeve (Hapi/Claude Code)","text":"<p>Connection: MCP stdio servers defined in <code>~/.config/claude-code/mcp_config.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"pulse-queue\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"--directory\", \"/path/to/reeve-bot\", \"python\", \"-m\", \"reeve.mcp.pulse_server\"]\n    },\n    \"telegram-notifier\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"--directory\", \"/path/to/reeve-bot\", \"python\", \"-m\", \"reeve.mcp.notification_server\"]\n    }\n  }\n}\n</code></pre> <p>Usage: Reeve calls <code>schedule_pulse()</code> when it needs to wake up in the future.</p>"},{"location":"architecture/project-structure/#2-external-event-listeners-telegram-email-etc","title":"2. External Event Listeners (Telegram, Email, etc.)","text":"<p>Connection: HTTP POST to <code>http://localhost:8765/api/pulse/trigger</code></p> <p>Authentication: Bearer token in <code>Authorization</code> header</p> <p>Example: <pre><code># telegram_listener.py\nrequests.post('http://localhost:8765/api/pulse/trigger',\n    headers={'Authorization': f'Bearer {API_TOKEN}'},\n    json={\n        'prompt': f'Telegram message from {user}: {text}',\n        'priority': 'HIGH',\n        'scheduled_at': 'now'\n    }\n)\n</code></pre></p>"},{"location":"architecture/project-structure/#3-the-desk-my_reeve","title":"3. The Desk (my_reeve/)","text":"<p>Connection: Pulse executor changes working directory to Desk before launching Hapi</p> <p>File Structure Expected: <pre><code>my_reeve/\n\u251c\u2500\u2500 CLAUDE.md           # System prompt (\"You are Reeve...\")\n\u251c\u2500\u2500 SKILLS.md           # Available tools/skills\n\u251c\u2500\u2500 Goals/              # High-level objectives\n\u251c\u2500\u2500 Responsibilities/   # Recurring duties\n\u251c\u2500\u2500 Preferences/        # User preferences\n\u2514\u2500\u2500 Diary/              # Reeve's internal logs\n</code></pre></p> <p>Execution Flow: 1. Pulse becomes due 2. Daemon executes pulse: <code>cd ~/my_reeve &amp;&amp; hapi run --prompt \"{pulse.prompt}\"</code> 3. Hapi/Claude Code runs with Desk as PWD \u2192 has access to all context files</p>"},{"location":"architecture/project-structure/#future-extensions","title":"Future Extensions","text":""},{"location":"architecture/project-structure/#1-activity-queue-low-urgency-events","title":"1. Activity Queue (Low-Urgency Events)","text":"<p>Structure: <pre><code>src/reeve/activity/\n\u251c\u2500\u2500 queue.py           # Separate queue for passive events\n\u2514\u2500\u2500 models.py          # Activity models\n</code></pre></p> <p>Design: Separate table, different processing loop (batched summaries)</p>"},{"location":"architecture/project-structure/#2-sub-agent-management","title":"2. Sub-Agent Management","text":"<p>Structure: <pre><code>src/reeve/agents/\n\u251c\u2500\u2500 manager.py         # Spawn/monitor sub-agents\n\u251c\u2500\u2500 blackboard.py      # Shared Desk file coordination\n\u2514\u2500\u2500 lifecycle.py       # Start/stop/cleanup\n</code></pre></p> <p>Design: Sub-agents run as separate Hapi sessions, report via Desk files</p>"},{"location":"architecture/project-structure/#3-additional-integrations","title":"3. Additional Integrations","text":"<p>Structure: <pre><code>src/reeve/integrations/\n\u251c\u2500\u2500 email.py           # Gmail listener\n\u251c\u2500\u2500 whatsapp.py        # WhatsApp listener\n\u251c\u2500\u2500 calendar.py        # Google Calendar sync\n\u2514\u2500\u2500 github.py          # GitHub webhook handler\n</code></pre></p> <p>Design: Each listener is an independent process that POSTs to HTTP API</p>"},{"location":"architecture/project-structure/#technology-choices","title":"Technology Choices","text":""},{"location":"architecture/project-structure/#why-uv","title":"Why uv?","text":"<ul> <li>Fast: Rust-based, faster than pip/poetry</li> <li>Lock file: Reproducible builds</li> <li>Modern: PEP 621 compliant pyproject.toml</li> <li>Script runner: <code>uv run python -m reeve.pulse</code></li> </ul>"},{"location":"architecture/project-structure/#why-fastapi-or-aiohttp","title":"Why FastAPI (or aiohttp)?","text":"<ul> <li>Async: Matches asyncio event loop in daemon</li> <li>Type hints: Pydantic validation</li> <li>Auto-docs: OpenAPI/Swagger for debugging</li> <li>Lightweight: Fast startup, low overhead</li> </ul>"},{"location":"architecture/project-structure/#why-sqlalchemy","title":"Why SQLAlchemy?","text":"<ul> <li>ORM: Type-safe models, migrations</li> <li>Async support: SQLAlchemy 2.0 async API</li> <li>Portable: Easy to swap SQLite \u2192 Postgres</li> <li>Battle-tested: Industry standard</li> </ul>"},{"location":"architecture/project-structure/#why-systemdsupervisor","title":"Why Systemd/Supervisor?","text":"<ul> <li>Process management: Auto-restart on crash</li> <li>Logging: stdout \u2192 syslog/journald</li> <li>Platform-native: Works on Linux servers</li> <li>Simple: Declarative config files</li> </ul>"},{"location":"architecture/project-structure/#development-workflow","title":"Development Workflow","text":""},{"location":"architecture/project-structure/#1-initial-setup","title":"1. Initial Setup","text":"<pre><code>cd /path/to/reeve-bot\nuv sync  # Install dependencies\ncp .env.example .env  # Configure environment\nuv run alembic upgrade head  # Initialize database\n</code></pre>"},{"location":"architecture/project-structure/#2-running-in-development","title":"2. Running in Development","text":"<pre><code># Terminal 1: Run daemon\nuv run python -m reeve.pulse\n\n# Terminal 2: Trigger test pulse\nuv run python cli/pulse.py schedule \"Test pulse\" --priority HIGH\n\n# Terminal 3: Watch logs\ntail -f ~/.reeve/logs/daemon.log\n</code></pre>"},{"location":"architecture/project-structure/#3-running-tests","title":"3. Running Tests","text":"<pre><code>uv run pytest tests/\n</code></pre>"},{"location":"architecture/project-structure/#4-production-deployment","title":"4. Production Deployment","text":"<pre><code># Install systemd service\nsudo cp reeve-daemon.service /etc/systemd/system/\nsudo systemctl enable reeve-daemon\nsudo systemctl start reeve-daemon\n\n# Check status\nsudo systemctl status reeve-daemon\njournalctl -u reeve-daemon -f\n</code></pre>"},{"location":"architecture/project-structure/#next-steps","title":"Next Steps","text":"<p>See the following documentation for detailed implementation:</p> <ol> <li>pulse-queue.md: Database schema, queue logic, priority system</li> <li>mcp-integration.md: MCP server tools, type hints, documentation</li> <li>deployment.md: Systemd setup, monitoring, troubleshooting</li> </ol>"},{"location":"architecture/pulse-queue/","title":"Pulse Queue Design","text":""},{"location":"architecture/pulse-queue/#overview","title":"Overview","text":"<p>The Pulse Queue is the core scheduling mechanism that enables Reeve's proactive behavior. It manages when and why Reeve should \"wake up\" to perform tasks, check for updates, or process information.</p>"},{"location":"architecture/pulse-queue/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/pulse-queue/#1-pulse","title":"1. Pulse","text":"<p>A Pulse represents a single scheduled wake-up event for Reeve. Each pulse contains:</p> <ul> <li>When to wake up (<code>scheduled_at</code>)</li> <li>Why to wake up (<code>prompt</code> - the context/task)</li> <li>How urgent it is (<code>priority</code>)</li> <li>What context to resume (<code>session_id</code>, <code>sticky_notes</code>)</li> <li>Current state (<code>status</code>)</li> </ul>"},{"location":"architecture/pulse-queue/#2-priority-system","title":"2. Priority System","text":"<p>Pulses have different priority levels to manage Reeve's attention:</p> <pre><code>class PulsePriority(str, Enum):\n    \"\"\"\n    Priority levels for pulses, determining execution order when multiple\n    pulses are due at the same time.\n\n    Higher priority pulses are processed first. Priority also affects\n    interrupt behavior and user notification urgency.\n    \"\"\"\n\n    CRITICAL = \"critical\"    # \ud83d\udea8 Emergency: User messages, system failures\n                             # - Interrupts deep work\n                             # - Bypasses DND settings\n                             # - Example: \"Wife texted: Emergency\"\n\n    HIGH = \"high\"           # \ud83d\udd14 Important: External events, user-facing tasks\n                             # - Scheduled alarms the user set\n                             # - External triggers (Telegram, Email)\n                             # - Example: \"Check flight status before departure\"\n\n    NORMAL = \"normal\"       # \u23f0 Standard: Regular maintenance, scheduled checks\n                             # - Periodic pulses (hourly check)\n                             # - Calendar event reminders\n                             # - Example: \"Daily 9 AM: Review calendar\"\n\n    LOW = \"low\"             # \ud83d\udccb Background: Non-urgent maintenance\n                             # - Cleanup tasks\n                             # - Background research\n                             # - Example: \"Weekly: Archive old notes\"\n\n    DEFERRED = \"deferred\"   # \ud83d\udd50 Postponed: Intentionally delayed\n                             # - User explicitly snoozed a task\n                             # - Rescheduled due to conflicts\n                             # - Example: \"Moved from Monday to Friday\"\n</code></pre> <p>Design Rationale: - String Enum: JSON-serializable, human-readable in DB - Explicit semantics: Each level has clear use cases - Emoji convention: Visual scanning in logs/UI - 5 levels: Enough granularity without decision paralysis</p>"},{"location":"architecture/pulse-queue/#3-pulse-status-lifecycle","title":"3. Pulse Status Lifecycle","text":"<pre><code>class PulseStatus(str, Enum):\n    \"\"\"\n    Status of a pulse in its lifecycle.\n\n    State transitions:\n    PENDING -&gt; PROCESSING -&gt; COMPLETED (success)\n                          -&gt; FAILED (error, will retry)\n                          -&gt; CANCELLED (user/system cancelled)\n    \"\"\"\n\n    PENDING = \"pending\"         # Waiting to be executed\n    PROCESSING = \"processing\"   # Currently executing\n    COMPLETED = \"completed\"     # Successfully executed\n    FAILED = \"failed\"           # Execution failed (see error_message)\n    CANCELLED = \"cancelled\"     # Manually cancelled by user/system\n</code></pre> <p>Design Rationale: - Simple states: Easy to reason about, no complex state machine - Processing state: Prevents duplicate execution (idempotency) - Failed vs Cancelled: Failed = retry possible, Cancelled = intentional stop</p> <pre><code>%%{init: {'theme': 'base', 'themeVariables': { 'lineColor': '#888'}}}%%\nflowchart TD\n    create([\"schedule_pulse()\"]) --&gt; pending[\"PENDING\"]\n    pending --&gt; |\"Daemon detects due pulse\"| processing\n    processing[\"PROCESSING\"]\n    processing --&gt; |\"Executor runs\"| result{Result?}\n\n    result --&gt; |Success| completed[\"COMPLETED\"]\n    result --&gt; |Failure| failed[\"FAILED\"]\n\n    failed --&gt; retry{\"retry_count &lt; max?\"}\n    retry --&gt; |Yes| new_pending[\"New PENDING&lt;br/&gt;(exponential backoff)\"]\n    retry --&gt; |No| remains[\"Remains FAILED\"]\n\n    cancel([\"cancel_pulse()\"]) -.-&gt; |\"At any time\"| cancelled[\"CANCELLED\"]\n    pending -.-&gt; cancelled\n\n    %% Styles\n    classDef status fill:#4a90a4,stroke:#2e6b7a,color:#fff\n    classDef success fill:#6b9b76,stroke:#4a7a54,color:#fff\n    classDef failure fill:#c4955a,stroke:#a67940,color:#fff\n    classDef action fill:#888,stroke:#666,color:#fff\n\n    class pending,processing status\n    class completed,new_pending success\n    class failed,remains,cancelled failure\n    class create,cancel,result,retry action</code></pre>"},{"location":"architecture/pulse-queue/#database-schema","title":"Database Schema","text":""},{"location":"architecture/pulse-queue/#pulse-model","title":"Pulse Model","text":"<pre><code>from sqlalchemy import Column, Integer, String, DateTime, Text, Enum as SQLEnum, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.sql import func\nfrom datetime import datetime\nfrom typing import Optional, List\n\nBase = declarative_base()\n\nclass Pulse(Base):\n    \"\"\"\n    Represents a scheduled wake-up event for Reeve.\n\n    A pulse is the fundamental unit of Reeve's proactive behavior. It defines\n    when Reeve should wake up, what it should think about, and with what urgency.\n\n    Pulses can be:\n    - Periodic (e.g., hourly heartbeat checks)\n    - Aperiodic (e.g., \"check ticket prices at 6:45 AM tomorrow\")\n    - Event-triggered (e.g., external Telegram message arrives)\n\n    Once a pulse executes, it launches a Hapi session with the pulse's prompt\n    as the initial context, allowing Reeve to take action.\n    \"\"\"\n\n    __tablename__ = \"pulses\"\n\n    # Primary Key\n    id = Column(Integer, primary_key=True, autoincrement=True)\n\n    # Scheduling Information\n    scheduled_at = Column(\n        DateTime(timezone=True),\n        nullable=False,\n        index=True,\n        comment=\"When this pulse should execute (UTC timestamp)\"\n    )\n\n    # Execution Context\n    prompt = Column(\n        Text,\n        nullable=False,\n        comment=\"The instruction/context for Reeve when this pulse fires. \"\n                \"This becomes the initial message in the Hapi session.\"\n    )\n\n    priority = Column(\n        SQLEnum(PulsePriority),\n        nullable=False,\n        default=PulsePriority.NORMAL,\n        index=True,\n        comment=\"Execution priority (determines order when multiple pulses are due)\"\n    )\n\n    # Session Continuity (Optional)\n    session_id = Column(\n        String(500),\n        nullable=True,\n        comment=\"Optional Hapi session ID or URL to resume existing context. \"\n                \"If None, a new session is created.\"\n    )\n\n    sticky_notes = Column(\n        JSON,\n        nullable=True,\n        comment=\"Optional list of reminder strings to inject into the prompt. \"\n                \"Example: ['Check if user replied to ski trip', 'Follow up on PR review']\"\n    )\n\n    # Execution State\n    status = Column(\n        SQLEnum(PulseStatus),\n        nullable=False,\n        default=PulseStatus.PENDING,\n        index=True,\n        comment=\"Current execution status of this pulse\"\n    )\n\n    # Execution Results (populated after execution)\n    executed_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        comment=\"When this pulse actually executed (may differ from scheduled_at)\"\n    )\n\n    execution_duration_ms = Column(\n        Integer,\n        nullable=True,\n        comment=\"How long the Hapi session took to complete (milliseconds)\"\n    )\n\n    error_message = Column(\n        Text,\n        nullable=True,\n        comment=\"Error message if status=FAILED. Used for debugging and retry logic.\"\n    )\n\n    # Retry Logic\n    retry_count = Column(\n        Integer,\n        nullable=False,\n        default=0,\n        comment=\"Number of times this pulse has been retried after failure\"\n    )\n\n    max_retries = Column(\n        Integer,\n        nullable=False,\n        default=3,\n        comment=\"Maximum retry attempts before giving up\"\n    )\n\n    # Metadata\n    created_at = Column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n        comment=\"When this pulse was created (for auditing)\"\n    )\n\n    created_by = Column(\n        String(100),\n        nullable=False,\n        default=\"system\",\n        comment=\"Who/what created this pulse. Examples: 'reeve', 'telegram_listener', 'user_cli'\"\n    )\n\n    tags = Column(\n        JSON,\n        nullable=True,\n        comment=\"Optional tags for categorization/filtering. \"\n                \"Example: ['hourly_check', 'calendar_sync', 'snowboarding']\"\n    )\n\n    # Database Indexes (in addition to individual column indexes)\n    # Composite index for the main query pattern\n    __table_args__ = (\n        # Most common query: \"Get all pending/processing pulses due before now, ordered by priority\"\n        Index('idx_pulse_execution', 'status', 'scheduled_at', 'priority'),\n        # For listing upcoming pulses: \"What's on Reeve's schedule?\"\n        Index('idx_pulse_upcoming', 'scheduled_at', 'status'),\n    )\n\n    def __repr__(self):\n        return (f\"&lt;Pulse(id={self.id}, scheduled_at={self.scheduled_at}, \"\n                f\"priority={self.priority.value}, status={self.status.value})&gt;\")\n</code></pre>"},{"location":"architecture/pulse-queue/#alembic-migration-strategy","title":"Alembic Migration Strategy","text":"<p>Initial Migration (<code>versions/001_create_pulses_table.py</code>): <pre><code>\"\"\"Create pulses table\n\nRevision ID: 001\nRevises:\nCreate Date: 2026-01-19\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import sqlite\n\nrevision = '001'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    op.create_table(\n        'pulses',\n        # ... (full schema as defined above)\n    )\n\ndef downgrade():\n    op.drop_table('pulses')\n</code></pre></p> <p>Why Alembic? - Version-controlled schema changes - Safe migrations in production - Rollback capability - Explicit upgrade path</p>"},{"location":"architecture/pulse-queue/#queue-management-logic","title":"Queue Management Logic","text":""},{"location":"architecture/pulse-queue/#pulsequeue-class","title":"PulseQueue Class","text":"<pre><code>from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy import select, and_, or_\nfrom datetime import datetime, timezone\nfrom typing import List, Optional\nimport asyncio\n\nclass PulseQueue:\n    \"\"\"\n    Manages the pulse queue: scheduling, retrieval, and execution tracking.\n\n    This is the core business logic layer for pulse management. It provides\n    a clean API for the MCP server, HTTP API, and daemon scheduler to interact\n    with the queue.\n\n    All database operations are async to support high concurrency.\n    \"\"\"\n\n    def __init__(self, db_url: str):\n        \"\"\"\n        Initialize the pulse queue with a database connection.\n\n        Args:\n            db_url: SQLAlchemy database URL. Examples:\n                - \"sqlite+aiosqlite:///~/.reeve/pulse_queue.db\" (async SQLite)\n                - \"postgresql+asyncpg://user:pass@localhost/reeve\" (async Postgres)\n        \"\"\"\n        self.engine = create_async_engine(db_url, echo=False)\n        self.SessionLocal = async_sessionmaker(\n            self.engine,\n            class_=AsyncSession,\n            expire_on_commit=False\n        )\n\n    async def schedule_pulse(\n        self,\n        scheduled_at: datetime,\n        prompt: str,\n        priority: PulsePriority = PulsePriority.NORMAL,\n        session_id: Optional[str] = None,\n        sticky_notes: Optional[List[str]] = None,\n        tags: Optional[List[str]] = None,\n        created_by: str = \"system\",\n        max_retries: int = 3\n    ) -&gt; int:\n        \"\"\"\n        Schedule a new pulse.\n\n        Args:\n            scheduled_at: When to execute (UTC timezone-aware datetime)\n            prompt: The instruction/context for Reeve\n            priority: Urgency level (default: NORMAL)\n            session_id: Optional Hapi session to resume\n            sticky_notes: Optional reminder strings to inject\n            tags: Optional categorization tags\n            created_by: Who created this pulse (for auditing)\n            max_retries: Max retry attempts on failure\n\n        Returns:\n            The pulse ID (integer)\n\n        Example:\n            pulse_id = await queue.schedule_pulse(\n                scheduled_at=datetime(2026, 1, 20, 9, 0, tzinfo=timezone.utc),\n                prompt=\"Daily morning briefing: Review calendar and tasks\",\n                priority=PulsePriority.NORMAL,\n                tags=[\"daily\", \"morning_routine\"]\n            )\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = Pulse(\n                scheduled_at=scheduled_at,\n                prompt=prompt,\n                priority=priority,\n                session_id=session_id,\n                sticky_notes=sticky_notes,\n                tags=tags,\n                created_by=created_by,\n                max_retries=max_retries,\n                status=PulseStatus.PENDING\n            )\n            session.add(pulse)\n            await session.commit()\n            await session.refresh(pulse)\n            return pulse.id\n\n    async def get_due_pulses(self, limit: int = 10) -&gt; List[Pulse]:\n        \"\"\"\n        Get pulses that are due for execution.\n\n        Returns pulses where:\n        - scheduled_at &lt;= now\n        - status = PENDING\n        - Ordered by: priority DESC, scheduled_at ASC\n\n        This ensures high-priority pulses execute first, and among same-priority\n        pulses, older ones execute first (FIFO).\n\n        Args:\n            limit: Maximum number of pulses to return\n\n        Returns:\n            List of Pulse objects ready for execution\n        \"\"\"\n        async with self.SessionLocal() as session:\n            now = datetime.now(timezone.utc)\n\n            stmt = (\n                select(Pulse)\n                .where(\n                    and_(\n                        Pulse.scheduled_at &lt;= now,\n                        Pulse.status == PulseStatus.PENDING\n                    )\n                )\n                .order_by(\n                    # Sort by priority enum value order (CRITICAL first)\n                    Pulse.priority,\n                    # Then by time (oldest first)\n                    Pulse.scheduled_at\n                )\n                .limit(limit)\n            )\n\n            result = await session.execute(stmt)\n            return list(result.scalars().all())\n\n    async def get_upcoming_pulses(\n        self,\n        limit: int = 20,\n        include_statuses: Optional[List[PulseStatus]] = None\n    ) -&gt; List[Pulse]:\n        \"\"\"\n        Get upcoming scheduled pulses (for visibility/introspection).\n\n        Args:\n            limit: Maximum number of pulses to return\n            include_statuses: Filter by status (default: [PENDING])\n\n        Returns:\n            List of Pulse objects ordered by scheduled_at\n        \"\"\"\n        if include_statuses is None:\n            include_statuses = [PulseStatus.PENDING]\n\n        async with self.SessionLocal() as session:\n            stmt = (\n                select(Pulse)\n                .where(Pulse.status.in_(include_statuses))\n                .order_by(Pulse.scheduled_at)\n                .limit(limit)\n            )\n\n            result = await session.execute(stmt)\n            return list(result.scalars().all())\n\n    async def mark_processing(self, pulse_id: int) -&gt; bool:\n        \"\"\"\n        Mark a pulse as currently processing (prevents duplicate execution).\n\n        Args:\n            pulse_id: The pulse to mark\n\n        Returns:\n            True if successfully marked, False if pulse was already processing/completed\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = await session.get(Pulse, pulse_id)\n\n            if not pulse or pulse.status != PulseStatus.PENDING:\n                return False\n\n            pulse.status = PulseStatus.PROCESSING\n            await session.commit()\n            return True\n\n    async def mark_completed(\n        self,\n        pulse_id: int,\n        execution_duration_ms: int\n    ) -&gt; None:\n        \"\"\"\n        Mark a pulse as successfully completed.\n\n        Args:\n            pulse_id: The pulse to mark\n            execution_duration_ms: How long execution took\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = await session.get(Pulse, pulse_id)\n\n            if pulse:\n                pulse.status = PulseStatus.COMPLETED\n                pulse.executed_at = datetime.now(timezone.utc)\n                pulse.execution_duration_ms = execution_duration_ms\n                await session.commit()\n\n    async def mark_failed(\n        self,\n        pulse_id: int,\n        error_message: str,\n        should_retry: bool = True\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Mark a pulse as failed.\n\n        If retry is enabled and max_retries not exceeded, schedules a new\n        retry pulse.\n\n        Args:\n            pulse_id: The pulse to mark as failed\n            error_message: Description of the failure\n            should_retry: Whether to attempt retry\n\n        Returns:\n            New pulse ID if retried, None otherwise\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = await session.get(Pulse, pulse_id)\n\n            if not pulse:\n                return None\n\n            pulse.status = PulseStatus.FAILED\n            pulse.error_message = error_message\n            pulse.executed_at = datetime.now(timezone.utc)\n\n            # Retry logic\n            new_pulse_id = None\n            if should_retry and pulse.retry_count &lt; pulse.max_retries:\n                # Schedule retry with exponential backoff: 2^retry_count minutes\n                retry_delay_minutes = 2 ** pulse.retry_count\n                retry_at = datetime.now(timezone.utc) + timedelta(minutes=retry_delay_minutes)\n\n                retry_pulse = Pulse(\n                    scheduled_at=retry_at,\n                    prompt=pulse.prompt,\n                    priority=pulse.priority,\n                    session_id=pulse.session_id,\n                    sticky_notes=pulse.sticky_notes,\n                    tags=pulse.tags,\n                    created_by=f\"retry_{pulse.created_by}\",\n                    max_retries=pulse.max_retries,\n                    retry_count=pulse.retry_count + 1,\n                    status=PulseStatus.PENDING\n                )\n\n                session.add(retry_pulse)\n                await session.flush()\n                new_pulse_id = retry_pulse.id\n\n            await session.commit()\n            return new_pulse_id\n\n    async def cancel_pulse(self, pulse_id: int) -&gt; bool:\n        \"\"\"\n        Cancel a pending pulse.\n\n        Args:\n            pulse_id: The pulse to cancel\n\n        Returns:\n            True if cancelled, False if pulse was not in cancellable state\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = await session.get(Pulse, pulse_id)\n\n            if not pulse or pulse.status not in [PulseStatus.PENDING]:\n                return False\n\n            pulse.status = PulseStatus.CANCELLED\n            await session.commit()\n            return True\n\n    async def reschedule_pulse(\n        self,\n        pulse_id: int,\n        new_scheduled_at: datetime\n    ) -&gt; bool:\n        \"\"\"\n        Reschedule a pending pulse to a different time.\n\n        Args:\n            pulse_id: The pulse to reschedule\n            new_scheduled_at: New execution time\n\n        Returns:\n            True if rescheduled, False if pulse was not pending\n        \"\"\"\n        async with self.SessionLocal() as session:\n            pulse = await session.get(Pulse, pulse_id)\n\n            if not pulse or pulse.status != PulseStatus.PENDING:\n                return False\n\n            pulse.scheduled_at = new_scheduled_at\n            await session.commit()\n            return True\n</code></pre>"},{"location":"architecture/pulse-queue/#design-decisions-rationale","title":"Design Decisions &amp; Rationale","text":""},{"location":"architecture/pulse-queue/#1-why-async-sqlalchemy","title":"1. Why Async SQLAlchemy?","text":"<p>Decision: Use <code>AsyncSession</code> and <code>async_sessionmaker</code></p> <p>Rationale: - Daemon runs an asyncio event loop (concurrent MCP server + HTTP API + scheduler) - Blocking DB calls would stall the entire event loop - Async allows thousands of concurrent operations - Future-proof for high-throughput scenarios</p>"},{"location":"architecture/pulse-queue/#2-why-string-enums","title":"2. Why String Enums?","text":"<p>Decision: <code>class PulsePriority(str, Enum)</code></p> <p>Rationale: - JSON-serializable (for API responses, MCP tool returns) - Human-readable in database (SQLite browser shows \"high\" not 2) - Type-safe in Python code - Better error messages (\"got 'urgent', expected 'high'\")</p>"},{"location":"architecture/pulse-queue/#3-why-composite-indexes","title":"3. Why Composite Indexes?","text":"<p>Decision: <code>Index('idx_pulse_execution', 'status', 'scheduled_at', 'priority')</code></p> <p>Rationale: - The main query (<code>get_due_pulses</code>) filters by status + scheduled_at, sorts by priority - Composite index covers entire query (no table scan) - SQLite can use leftmost prefix for other queries - Tradeoff: Slightly slower writes (index maintenance), but reads are 100x faster</p>"},{"location":"architecture/pulse-queue/#4-why-retry-logic-in-db","title":"4. Why Retry Logic in DB?","text":"<p>Decision: Store <code>retry_count</code> and <code>max_retries</code> in Pulse model</p> <p>Rationale: - Self-contained: Each pulse knows its own retry policy - Exponential backoff: 1min \u2192 2min \u2192 4min \u2192 8min - Failure forensics: Can query \"which pulses failed repeatedly?\" - Future: Could add per-priority retry policies</p>"},{"location":"architecture/pulse-queue/#5-why-separate-created_by-field","title":"5. Why Separate <code>created_by</code> Field?","text":"<p>Decision: Track who/what created each pulse</p> <p>Rationale: - Debugging: \"Why did this pulse fire?\" - Analytics: \"How many pulses come from Telegram vs. Reeve itself?\" - Audit trail: Security/compliance - Future: Rate limiting per source</p>"},{"location":"architecture/pulse-queue/#execution-flow","title":"Execution Flow","text":""},{"location":"architecture/pulse-queue/#daemon-main-loop","title":"Daemon Main Loop","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  While True (every 1 second):           \u2502\n\u2502                                         \u2502\n\u2502  1. Get due pulses from queue           \u2502\n\u2502  2. For each pulse (up to 10):          \u2502\n\u2502     a. Mark as PROCESSING               \u2502\n\u2502     b. Launch Hapi session (async)      \u2502\n\u2502     c. Wait for completion              \u2502\n\u2502     d. Mark as COMPLETED/FAILED         \u2502\n\u2502  3. Sleep 1 second                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Why 1 second polling? - Sub-second precision (vs. cron's 1-minute minimum) - Low CPU overhead (DB query is cheap with indexes) - Can batch multiple due pulses in one iteration - Future: Could use DB triggers + notify/listen for zero-latency</p>"},{"location":"architecture/pulse-queue/#parallel-execution","title":"Parallel Execution","text":"<p>Option A: Sequential (Initial Implementation) - Process one pulse at a time - Simple, predictable - Good for debugging</p> <p>Option B: Parallel (Future Optimization) - Process up to N pulses concurrently - Faster overall throughput - Risk: Resource contention (CPU, Hapi sessions)</p> <p>Recommendation: Start with Sequential, add Parallel after observing real-world load.</p>"},{"location":"architecture/pulse-queue/#next-steps","title":"Next Steps","text":"<p>See mcp-integration.md for how Reeve interacts with this queue via MCP tools.</p>"},{"location":"architecture/stream-parser/","title":"Stream Parser","text":""},{"location":"architecture/stream-parser/#overview","title":"Overview","text":"<p>The <code>HapiStreamParser</code> parses JSONL output from hapi's <code>--output-format stream-json --verbose</code> mode. It extracts session information, tool usage metrics, and error details from the streaming output.</p> <p>Why it matters: The parser enables better error diagnostics by extracting the <code>session_id</code> even when execution fails. This allows operators to investigate failed pulses in the Claude Code session history.</p>"},{"location":"architecture/stream-parser/#usage","title":"Usage","text":"<pre><code>from reeve.pulse.stream_parser import HapiStreamParser\n\nparser = HapiStreamParser()\nresult = parser.parse_all(stdout)\n\nprint(f\"Session: {result.session_id}\")\nprint(f\"Error: {result.error_message}\")\nprint(f\"Tool calls: {result.tool_call_count}\")\n</code></pre>"},{"location":"architecture/stream-parser/#incremental-parsing","title":"Incremental Parsing","text":"<p>For streaming scenarios, parse lines as they arrive:</p> <pre><code>parser = HapiStreamParser()\nfor line in stdout.split(\"\\n\"):\n    event = parser.parse_line(line)\n    if event:\n        print(f\"Event: {event.type}/{event.subtype}\")\n</code></pre>"},{"location":"architecture/stream-parser/#event-types","title":"Event Types","text":"Type Subtype Description Key Fields <code>system</code> <code>init</code> Session initialization <code>session_id</code> <code>assistant</code> - Claude's response <code>tool_uses[]</code> <code>user</code> - Tool results <code>tool_results[]</code> <code>result</code> - Final outcome <code>is_error</code>, <code>error_message</code>"},{"location":"architecture/stream-parser/#data-models","title":"Data Models","text":""},{"location":"architecture/stream-parser/#streamparseresult","title":"StreamParseResult","text":"<p>Aggregated result from parsing a complete stream.</p> Field Type Description <code>session_id</code> <code>str | None</code> Session ID from init event (available early) <code>is_error</code> <code>bool</code> Whether the stream ended with an error <code>error_message</code> <code>str | None</code> Error message from result event <code>tool_call_count</code> <code>int</code> Total number of tool calls made <code>events</code> <code>list[HapiStreamEvent]</code> All parsed events"},{"location":"architecture/stream-parser/#hapistreamevent","title":"HapiStreamEvent","text":"<p>A single parsed event from the JSONL stream.</p> Field Type Description <code>type</code> <code>HapiEventType</code> Event category <code>subtype</code> <code>str | None</code> Event subtype (e.g., \"init\") <code>session_id</code> <code>str | None</code> Session identifier if present <code>is_error</code> <code>bool</code> Whether this is an error event <code>error_message</code> <code>str | None</code> Error message if applicable <code>tool_uses</code> <code>list[ToolUseInfo]</code> Tool calls in assistant events <code>tool_results</code> <code>list[ToolResultInfo]</code> Results in user events"},{"location":"architecture/stream-parser/#tooluseinfo","title":"ToolUseInfo","text":"<p>Information about a tool call.</p> Field Type Description <code>id</code> <code>str</code> Unique identifier for the tool use <code>name</code> <code>str</code> Name of the tool being called"},{"location":"architecture/stream-parser/#toolresultinfo","title":"ToolResultInfo","text":"<p>Information about a tool result.</p> Field Type Description <code>tool_use_id</code> <code>str</code> ID of the corresponding tool_use"},{"location":"architecture/stream-parser/#integration-with-executor","title":"Integration with Executor","text":"<p>The <code>PulseExecutor</code> uses the stream parser to extract diagnostics from hapi output:</p> <pre><code># In executor.py\nclass PulseExecutor:\n    def __init__(self, ...):\n        self.stream_parser = HapiStreamParser()\n\n    async def execute(self, prompt: str, ...) -&gt; ExecutionResult:\n        # Run hapi with stream-json output\n        process = await asyncio.create_subprocess_exec(\n            hapi_command,\n            \"--output-format\", \"stream-json\",\n            \"--verbose\",\n            ...\n        )\n        stdout, stderr = await process.communicate()\n\n        # Parse output to extract session_id and error details\n        parse_result = self.stream_parser.parse_all(stdout.decode())\n\n        # Session ID is available even if execution failed!\n        return ExecutionResult(\n            success=process.returncode == 0,\n            session_id=parse_result.session_id,\n            error_message=parse_result.error_message,\n            tool_call_count=parse_result.tool_call_count,\n        )\n</code></pre> <p>The parser handles edge cases like: - Terminal escape sequences prepended to JSON lines (WSL, some terminals) - Non-JSON status messages interspersed in output - Missing or malformed events</p>"},{"location":"roadmap/","title":"Implementation Roadmap","text":"<p>This document provides a step-by-step implementation guide for building the Pulse Queue system from scratch. Follow this roadmap in order, as later phases depend on earlier foundations.</p> <p>Estimated Total Effort: 3-4 days for full implementation + testing</p>"},{"location":"roadmap/#phase-overview","title":"Phase Overview","text":"Phase Title Status Phase 1 Foundation \u2705 Completed Phase 2 Queue Management \u2705 Completed Phase 3 MCP Servers \u2705 Completed Phase 4 Pulse Executor \u2705 Completed Phase 5 Daemon \u2705 Completed Phase 6 HTTP API \u2705 Completed Phase 7 Telegram Integration \u2705 Completed Phase 8 Deployment \u2705 Completed Phase 9 Integration Testing &amp; Polish \u23f3 Pending"},{"location":"roadmap/#dependencies-between-phases","title":"Dependencies Between Phases","text":"<pre><code>Phase 1 (Foundation)\n    \u2193\nPhase 2 (Queue) \u2190\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2193                 \u2502\n    \u251c\u2500\u2192 Phase 3 (MCP) \u2502\n    \u2502       \u2193         \u2502\n    \u2514\u2500\u2192 Phase 4 (Executor)\n            \u2193         \u2502\n        Phase 5 (Daemon)\n            \u2193         \u2502\n        Phase 6 (API) \u2190\u2518\n            \u2193\n        Phase 7 (Telegram)\n            \u2193\n        Phase 8 (Deployment)\n            \u2193\n        Phase 9 (Testing)\n</code></pre> <p>Key: Phases 3-6 can partially overlap, but each depends on Phase 2 (Queue).</p>"},{"location":"roadmap/#success-criteria","title":"Success Criteria","text":"<p>The Pulse Queue system is complete when:</p> <ol> <li>Reeve can schedule its own wake-ups</li> <li>\u2705 MCP tools work from Claude Code (Phase 3)</li> <li>\u2705 Executor can launch Hapi sessions (Phase 4)</li> <li>\u2705 Pulses execute at correct times (Phase 5)</li> <li>\u2705 Session resumption supported by executor (Phase 4)</li> <li> <p>\u2705 End-to-end scheduling + execution (Phase 5)</p> </li> <li> <p>External events trigger Reeve</p> </li> <li>\u2705 Telegram messages \u2192 immediate pulses (Phase 7)</li> <li>\u2705 HTTP API accessible to other integrations (Phase 6)</li> <li> <p>\u2705 Authentication enforced (Phase 6)</p> </li> <li> <p>Production-ready</p> </li> <li>\u2705 Runs as systemd service (Phase 8)</li> <li>\u2705 Automatic restarts on crash (Phase 8)</li> <li>\u2705 Logs rotated and monitored (Phase 8)</li> <li> <p>\u2705 Database backed up daily (Phase 8)</p> </li> <li> <p>Documented</p> </li> <li>\u2705 Implementation guide complete</li> <li>\u2705 MCP setup guide complete (docs/MCP_SETUP.md)</li> <li>\u2705 Deployment guide complete (Phase 8)</li> <li>\u2705 Troubleshooting guide complete (Phase 8)</li> <li> <p>\u2705 Code well-commented</p> </li> <li> <p>Tested</p> </li> <li>\u2705 Unit tests for queue, MCP, and executor components (191/191 tests passing)</li> <li>\u23f3 Integration tests for full flows (Phase 9)</li> <li>\u23f3 Manual testing completed (Phase 9)</li> <li>\u23f3 Performance acceptable (Phase 9)</li> </ol>"},{"location":"roadmap/#demo-scripts","title":"Demo Scripts","text":"<p>All demo scripts are in the <code>demos/</code> directory:</p> Script Description <code>phase1_database_demo.py</code> Database schema and model creation <code>phase2_queue_demo.py</code> Queue operations (schedule, query, retry) <code>phase3_mcp_demo.py</code> MCP tools integration <code>phase4_executor_demo.py</code> Pulse execution with Hapi <code>phase5_daemon_demo.py</code> Daemon orchestration <code>phase6_api_demo.py</code> HTTP API endpoints <code>phase7_telegram_demo.py</code> Telegram bot integration <code>phase8_deployment_demo.sh</code> Systemd deployment"},{"location":"roadmap/#quick-start","title":"Quick Start","text":"<pre><code># Install dependencies\nuv sync\n\n# Run Alembic migrations\nuv run alembic upgrade head\n\n# Run tests\nuv run pytest tests/ -v\n\n# Run daemon (Phase 5+)\nuv run python -m reeve.pulse\n</code></pre>"},{"location":"roadmap/#code-quality-standards","title":"Code Quality Standards","text":"<ul> <li>Type hints: All functions fully typed</li> <li>Docstrings: All public APIs documented</li> <li>Error handling: Graceful failures with logging</li> <li>Testing: Aim for &gt;80% coverage</li> <li>Formatting: Use <code>black</code> and <code>isort</code></li> </ul>"},{"location":"roadmap/phase-1-foundation/","title":"Phase 1 - Foundation","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-1-foundation/#phase-1-foundation-completed","title":"Phase 1: Foundation \u2705 COMPLETED","text":"<p>Goal: Set up project structure, dependencies, and database schema.</p> <p>Status: \u2705 Completed on 2026-01-19 (Commit: ece5e41)</p>"},{"location":"roadmap/phase-1-foundation/#tasks","title":"Tasks","text":"<ol> <li>Project Structure \u2705</li> <li>Create directory structure as per Project Structure</li> <li> <p>Initialize <code>src/reeve/</code> package with <code>__init__.py</code> files</p> </li> <li> <p>Dependencies \u2705</p> </li> <li>Update <code>pyproject.toml</code> with required packages:      <pre><code>[project]\nname = \"reeve-bot\"\nversion = \"0.1.0\"\nrequires-python = \"&gt;=3.11\"\ndependencies = [\n    \"sqlalchemy&gt;=2.0\",\n    \"aiosqlite&gt;=0.19.0\",\n    \"alembic&gt;=1.13.0\",\n    \"fastapi&gt;=0.109.0\",\n    \"uvicorn&gt;=0.27.0\",\n    \"pydantic&gt;=2.5.0\",\n    \"requests&gt;=2.32.0\",\n    \"mcp&gt;=0.9.0\",  # MCP SDK\n    \"python-dotenv&gt;=1.0.0\",\n]\n</code></pre></li> <li> <p>Run: <code>uv sync</code></p> </li> <li> <p>Enums \u2705 (<code>src/reeve/pulse/enums.py</code>)</p> </li> <li>Implement <code>PulsePriority(str, Enum)</code> with 5 levels</li> <li>Implement <code>PulseStatus(str, Enum)</code> with 5 states</li> <li> <p>See Pulse Queue Design for full definitions</p> </li> <li> <p>Database Models \u2705 (<code>src/reeve/pulse/models.py</code>)</p> </li> <li>Implement <code>Pulse</code> SQLAlchemy model</li> <li>Define all columns as specified in design doc</li> <li>Add composite indexes</li> <li> <p>Test model creation:      <pre><code>from reeve.pulse.models import Base, Pulse\nfrom sqlalchemy import create_engine\nengine = create_engine(\"sqlite:///test.db\")\nBase.metadata.create_all(engine)\n</code></pre></p> </li> <li> <p>Alembic Setup \u2705</p> </li> <li>Initialize: <code>uv run alembic init alembic</code></li> <li>Configure <code>alembic.ini</code> with <code>sqlalchemy.url</code></li> <li>Configure <code>alembic/env.py</code> with model auto-discovery</li> <li>Create initial migration:      <pre><code>uv run alembic revision --autogenerate -m \"Create pulses table\"\nuv run alembic upgrade head\n</code></pre></li> <li>Verify: <code>sqlite3 ~/.reeve/pulse_queue.db .schema</code></li> </ol>"},{"location":"roadmap/phase-1-foundation/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Clean project structure</li> <li>\u2705 Working database with <code>pulses</code> table (Migration: 07ce7ae63b4a)</li> <li>\u2705 Type-safe enums</li> <li>\u2705 Alembic migrations working</li> <li>\u2705 Validation tests passing</li> </ul>"},{"location":"roadmap/phase-1-foundation/#validation","title":"Validation","text":"<pre><code># Test script\nfrom reeve.pulse.models import Pulse\nfrom reeve.pulse.enums import PulsePriority, PulseStatus\nfrom datetime import datetime, timezone\n\npulse = Pulse(\n    scheduled_at=datetime.now(timezone.utc),\n    prompt=\"Test pulse\",\n    priority=PulsePriority.NORMAL,\n    status=PulseStatus.PENDING\n)\nprint(f\"Created: {pulse}\")\n</code></pre>"},{"location":"roadmap/phase-1-foundation/#demo","title":"Demo","text":"<p>Database Schema:</p> <pre><code># Run the demo script\nuv run python demos/phase1_database_demo.py\n\n# Expected output:\n# \u2713 Database initialized at ~/.reeve/pulse_queue.db\n# \u2713 Created pulse with ID: 1\n# \u2713 Verified pulse in database:\n#   - Scheduled at: 2026-01-19 10:30:00+00:00\n#   - Priority: NORMAL\n#   - Status: PENDING\n# \u2713 Phase 1 Demo Complete!\n</code></pre> <p>Next: Phase 2: Queue Management</p>"},{"location":"roadmap/phase-2-queue/","title":"Phase 2 - Queue","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-2-queue/#phase-2-queue-management-completed","title":"Phase 2: Queue Management \u2705 COMPLETED","text":"<p>Goal: Implement core business logic for queue operations.</p> <p>Status: \u2705 Completed on 2026-01-19 (Commit: 52eac4c)</p>"},{"location":"roadmap/phase-2-queue/#tasks","title":"Tasks","text":"<ol> <li>PulseQueue Class (<code>src/reeve/pulse/queue.py</code>) \u2705</li> <li>Implemented async SQLAlchemy session management</li> <li>Implemented all methods:<ul> <li><code>schedule_pulse()</code> - Create new pulse</li> <li><code>get_due_pulses()</code> - Query pending pulses with priority ordering</li> <li><code>get_upcoming_pulses()</code> - List future pulses</li> <li><code>get_pulse()</code> - Retrieve pulse by ID</li> <li><code>mark_processing()</code> - Transition to processing</li> <li><code>mark_completed()</code> - Mark success</li> <li><code>mark_failed()</code> - Handle failures + retry logic with exponential backoff</li> <li><code>cancel_pulse()</code> - Cancel pending</li> <li><code>reschedule_pulse()</code> - Change time</li> <li><code>initialize()</code> - Initialize database schema</li> <li><code>close()</code> - Clean up resources</li> </ul> </li> <li> <p>Priority ordering using SQLAlchemy CASE statement</p> </li> <li> <p>Unit Tests (<code>tests/test_pulse_queue.py</code>) \u2705</p> </li> <li>Test database: <code>sqlite+aiosqlite:///:memory:</code></li> <li> <p>29 comprehensive unit tests covering:</p> <ul> <li>All CRUD operations</li> <li>Priority ordering (CRITICAL \u2192 HIGH \u2192 NORMAL \u2192 LOW \u2192 DEFERRED)</li> <li>Time-based FIFO within same priority</li> <li>Retry logic with exponential backoff (2^retry_count minutes)</li> <li>Concurrent operations</li> <li>Edge cases (nonexistent pulses, invalid states, etc.)</li> <li>Timezone awareness</li> </ul> </li> <li> <p>Configuration (<code>src/reeve/utils/config.py</code>) \u2705</p> </li> <li>Implemented <code>ReeveConfig</code> class with environment variable support</li> <li>Path expansion for <code>~</code> and <code>$VAR</code></li> <li>Database URL handling (async and sync modes)</li> <li> <p>Singleton pattern with <code>get_config()</code> and <code>reload_config()</code></p> </li> <li> <p>Enhanced Database Models (<code>src/reeve/pulse/models.py</code>) \u2705</p> </li> <li>Added <code>TZDateTime</code> custom type for proper timezone handling with SQLite</li> <li>Updated to SQLAlchemy 2.0 style (<code>orm.declarative_base</code>)</li> <li> <p>All datetime fields preserve timezone information</p> </li> <li> <p>Validation Tests (<code>tests/test_phase2_validation.py</code>) \u2705</p> </li> <li>Integration test from roadmap validation example</li> <li>End-to-end workflow validation</li> </ol>"},{"location":"roadmap/phase-2-queue/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Fully functional <code>PulseQueue</code> class</li> <li>\u2705 100% test coverage for queue operations (33/33 tests passed)</li> <li>\u2705 Configuration management</li> <li>\u2705 Timezone-aware datetime handling</li> <li>\u2705 Code formatted with black and isort</li> </ul>"},{"location":"roadmap/phase-2-queue/#validation","title":"Validation","text":"<pre><code># All tests passing\nuv run pytest tests/ -v\n# Result: 33 passed (3 Phase 1 + 1 Phase 2 integration + 29 Phase 2 unit tests)\n</code></pre>"},{"location":"roadmap/phase-2-queue/#demo","title":"Demo","text":"<p>Queue Operations:</p> <pre><code># Run the demo script\nuv run python demos/phase2_queue_demo.py\n\n# Expected output:\n# \u2713 Initialized PulseQueue\n# \u2713 Scheduled pulse #1: \"High priority task\" (due in 5 seconds, priority: HIGH)\n# \u2713 Scheduled pulse #2: \"Normal maintenance\" (due in 10 seconds, priority: NORMAL)\n# \u2713 Scheduled pulse #3: \"Low priority cleanup\" (due in 15 seconds, priority: LOW)\n#\n# Upcoming pulses (3):\n# \ud83d\udd14 #1 - HIGH - in 5s - \"High priority task\"\n# \u23f0 #2 - NORMAL - in 10s - \"Normal maintenance\"\n# \ud83d\udccb #3 - LOW - in 15s - \"Low priority cleanup\"\n#\n# \u2713 Marked pulse #1 as PROCESSING\n# \u2713 Marked pulse #1 as COMPLETED\n#\n# \u2713 Simulating failure for pulse #2...\n# \u2713 Marked pulse #2 as FAILED (retry_count=1, will retry in 2 minutes)\n#\n# \u2713 Cancelled pulse #3\n#\n# Final status:\n# - Pulse #1: COMPLETED \u2705\n# - Pulse #2: PENDING (scheduled for retry in ~2 minutes) \ud83d\udd04\n# - Pulse #3: CANCELLED \u274c\n#\n# \u2713 Phase 2 Demo Complete!\n</code></pre> <p>Previous: Phase 1: Foundation</p> <p>Next: Phase 3: MCP Servers</p>"},{"location":"roadmap/phase-3-mcp/","title":"Phase 3 - MCP","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-3-mcp/#phase-3-mcp-servers-completed","title":"Phase 3: MCP Servers \u2705 COMPLETED","text":"<p>Goal: Expose queue functionality to Reeve via MCP tools.</p> <p>Status: \u2705 Completed on 2026-01-19</p>"},{"location":"roadmap/phase-3-mcp/#tasks","title":"Tasks","text":"<ol> <li>Pulse Queue MCP Server (<code>src/reeve/mcp/pulse_server.py</code>) \u2705</li> <li>Implemented all tools using FastMCP:<ul> <li><code>schedule_pulse()</code> - Schedule pulses with flexible time parsing</li> <li><code>list_upcoming_pulses()</code> - View scheduled pulses with visual formatting</li> <li><code>cancel_pulse()</code> - Cancel pending pulses</li> <li><code>reschedule_pulse()</code> - Change pulse timing</li> </ul> </li> <li>Type-safe with <code>Annotated[Type, Field(...)]</code></li> <li>Comprehensive docstrings with usage examples</li> <li>Helper functions:<ul> <li><code>_parse_time_string()</code> - ISO 8601, relative times (\"in 2 hours\"), keywords (\"now\")</li> <li><code>_priority_emoji()</code> and <code>_status_emoji()</code> - Visual indicators</li> </ul> </li> <li> <p>Graceful error handling with user-friendly messages</p> </li> <li> <p>Telegram Notifier MCP Server (<code>src/reeve/mcp/notification_server.py</code>) \u2705</p> </li> <li>Implemented tools using FastMCP:<ul> <li><code>send_notification()</code> - Push notifications via Telegram with auto-generated session links</li> </ul> </li> <li>Auto-detects session ID via FastMCP Context and generates \"View in Claude Code\" button</li> <li>Integrated with Telegram Bot API</li> <li>Supports MarkdownV2, HTML, and plain text formatting</li> <li>Priority levels: silent, normal, critical (controls notification sound)</li> <li>Configurable Hapi base URL via <code>HAPI_BASE_URL</code> environment variable</li> <li> <p>Error handling for API failures</p> </li> <li> <p>MCP Configuration \u2705</p> </li> <li>Created <code>mcp_config.json.example</code> template</li> <li>Documentation: <code>docs/MCP_SETUP.md</code> with setup and troubleshooting</li> <li>Both servers configured with <code>uv run</code> commands</li> <li> <p>Server startup tested successfully</p> </li> <li> <p>Testing \u2705</p> </li> <li>Created MCP server test suite (split into 3 files, 18 tests total):<ul> <li><code>tests/test_pulse_server_helpers.py</code> - 11 tests (time parsing, emoji helpers)</li> <li><code>tests/test_pulse_server_tools.py</code> - 3 tests (MCP tools, integration)</li> <li><code>tests/test_notification_server.py</code> - 4 tests (Telegram notifier)</li> </ul> </li> <li>All tests pass (51/51 total across all phases)</li> </ol>"},{"location":"roadmap/phase-3-mcp/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Two working MCP servers built with FastMCP</li> <li>\u2705 Type-safe tool definitions with Pydantic validation</li> <li>\u2705 Comprehensive documentation for Claude and users</li> <li>\u2705 18 comprehensive tests split across 3 files with mocking and integration coverage</li> <li>\u2705 Example configuration and setup guide</li> </ul>"},{"location":"roadmap/phase-3-mcp/#validation","title":"Validation","text":"<pre><code># Run tests\nuv run pytest tests/test_pulse_server_helpers.py tests/test_pulse_server_tools.py tests/test_notification_server.py -v\n# Result: 18/18 tests PASSED\n\n# Test server startup\nuv run python -m reeve.mcp.pulse_server\n# Server starts and waits for stdio input \u2713\n\nuv run python -m reeve.mcp.notification_server\n# Server starts (requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID env vars) \u2713\n\n# Manual testing with Claude Code\n# Configure MCP servers in ~/.config/claude-code/mcp_config.json\n# Then in Claude Code session, tools are automatically available\n</code></pre>"},{"location":"roadmap/phase-3-mcp/#demo","title":"Demo","text":""},{"location":"roadmap/phase-3-mcp/#step-1-configure-mcp-servers-one-time-setup","title":"Step 1: Configure MCP servers (one-time setup)","text":"<pre><code># Copy example config\ncp mcp_config.json.example ~/.config/claude-code/mcp_config.json\n\n# Edit to add Telegram credentials (optional for telegram-notifier)\n# TELEGRAM_BOT_TOKEN: Get from @BotFather on Telegram\n# TELEGRAM_CHAT_ID: Your Telegram user ID\n</code></pre>"},{"location":"roadmap/phase-3-mcp/#step-2a-demo-via-interactive-script","title":"Step 2a: Demo via Interactive Script","text":"<pre><code># Run the demo script (doesn't require MCP configuration)\nuv run python demos/phase3_mcp_demo.py\n\n# Expected output:\n# \u2713 Testing Pulse Queue MCP Tools\n# \u2713 Scheduled pulse #1: \"Morning briefing\" (in 1 hour, priority: HIGH)\n# \u2713 Scheduled pulse #2: \"Afternoon check-in\" (in 4 hours, priority: NORMAL)\n# \u2713 Listed 2 upcoming pulses\n# \u2713 Rescheduled pulse #1 to 30 minutes from now\n# \u2713 Cancelled pulse #2\n#\n# \u2713 Testing Telegram Notifier MCP Tool\n# \u2713 Sent test notification: \"Phase 3 demo completed! \ud83c\udf89\"\n#   (Check your Telegram for the message)\n#\n# \u2713 Phase 3 Demo Complete!\n</code></pre>"},{"location":"roadmap/phase-3-mcp/#step-2b-demo-via-claude-code-after-mcp-configuration","title":"Step 2b: Demo via Claude Code (after MCP configuration)","text":"<p>In a Claude Code session, use the MCP tools directly:</p> <ol> <li> <p>Schedule a pulse:    <pre><code>schedule_pulse(\n  scheduled_at=\"in 30 minutes\",\n  prompt=\"Test notification from MCP\",\n  priority=\"high\"\n)\n</code></pre></p> </li> <li> <p>List upcoming pulses:    <pre><code>list_upcoming_pulses(limit=10)\n</code></pre></p> </li> <li> <p>Send a notification:    <pre><code>send_notification(\n  message=\"Testing Telegram integration!\",\n  priority=\"normal\"\n)\n</code></pre></p> </li> <li> <p>Cancel a pulse:    <pre><code>cancel_pulse(pulse_id=1)\n</code></pre></p> </li> </ol> <p>Previous: Phase 2: Queue Management</p> <p>Next: Phase 4: Pulse Executor</p>"},{"location":"roadmap/phase-4-executor/","title":"Phase 4 - Executor","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-4-executor/#phase-4-pulse-executor-completed","title":"Phase 4: Pulse Executor \u2705 COMPLETED","text":"<p>Goal: Execute pulses by launching Hapi sessions.</p> <p>Status: \u2705 Completed on 2026-01-19</p>"},{"location":"roadmap/phase-4-executor/#tasks","title":"Tasks","text":"<ol> <li>PulseExecutor Class (<code>src/reeve/pulse/executor.py</code>) \u2705</li> <li>Implemented <code>execute()</code> method with full async support</li> <li>Launches Hapi subprocess with correct working directory</li> <li>Handles sticky notes (appended to prompt, not prepended)</li> <li>Captures stdout/stderr with UTF-8 error handling</li> <li>Reports success/failure with detailed error messages</li> <li>Includes timeout handling with configurable defaults</li> <li> <p>See Daemon &amp; API</p> </li> <li> <p>Testing \u2705</p> </li> <li>18 comprehensive unit tests with mocked Hapi command</li> <li>Tests prompt building with and without sticky notes</li> <li>Tests error handling (Hapi crash, timeout, command not found, invalid paths)</li> <li>Tests configuration (path expansion, custom timeout)</li> <li>Integration-style tests for full execution flow</li> </ol>"},{"location":"roadmap/phase-4-executor/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Working executor that can launch Hapi with full error handling</li> <li>\u2705 18 comprehensive tests with mocked Hapi (all passing)</li> </ul>"},{"location":"roadmap/phase-4-executor/#validation","title":"Validation","text":"<pre><code># Test script\nimport asyncio\nfrom reeve.pulse.executor import PulseExecutor\n\nasync def test():\n    executor = PulseExecutor(\"hapi\", \"~/my_reeve\")\n\n    result = await executor.execute(\n        prompt=\"Echo hello world and exit\",\n        working_dir=\"~/my_reeve\"\n    )\n\n    print(f\"Return code: {result['return_code']}\")\n    print(f\"Output: {result['stdout']}\")\n\nasyncio.run(test())\n</code></pre>"},{"location":"roadmap/phase-4-executor/#demo","title":"Demo","text":""},{"location":"roadmap/phase-4-executor/#with-real-hapi","title":"With Real Hapi","text":"<p>Note: This demo requires Hapi to be installed and configured. If Hapi is not available, the demo will use a mock executor.</p> <pre><code># Run the demo script\nuv run python demos/phase4_executor_demo.py\n\n# Expected output (with real Hapi):\n# \u2713 Testing PulseExecutor\n# \u2713 Building prompt with sticky notes...\n#\n# Prompt to send:\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Tell me a programming joke and then exit\n#\n# \ud83d\udccc Reminders:\n#   - Keep it short\n#   - Make it funny\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n#\n# \u2713 Launching Hapi session...\n# \u2713 Execution completed successfully!\n#\n# Output:\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Why do programmers prefer dark mode?\n# Because light attracts bugs! \ud83d\udc1b\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n#\n# Execution time: 2.3 seconds\n# \u2713 Phase 4 Demo Complete!\n</code></pre>"},{"location":"roadmap/phase-4-executor/#mock-mode-if-hapi-not-available","title":"Mock Mode (if Hapi not available)","text":"<pre><code># The demo script will automatically detect if Hapi is available\n# If not, it will demonstrate the executor with a mock command\nuv run python demos/phase4_executor_demo.py --mock\n\n# Expected output (mock mode):\n# \u2139 Hapi not found, using mock executor\n# \u2713 Mock execution successful\n# \u2713 Prompt building tested\n# \u2713 Timeout handling tested\n# \u2713 Error handling tested\n# \u2713 Phase 4 Demo Complete (mock mode)!\n</code></pre> <p>Previous: Phase 3: MCP Servers</p> <p>Next: Phase 5: Daemon</p>"},{"location":"roadmap/phase-5-daemon/","title":"Phase 5 - Daemon","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-5-daemon/#phase-5-daemon-completed","title":"Phase 5: Daemon \u2705 COMPLETED","text":"<p>Goal: Build the main daemon process that ties everything together.</p> <p>Status: \u2705 Completed on 2026-01-22 (Commit: b9b9714)</p>"},{"location":"roadmap/phase-5-daemon/#tasks","title":"Tasks","text":"<ol> <li>Daemon Class (<code>src/reeve/pulse/daemon.py</code>) \u2705</li> <li>Implemented <code>PulseDaemon</code> class (273 lines)</li> <li>Implemented <code>_scheduler_loop()</code> - polls every 1 second</li> <li>Implemented <code>_execute_pulse()</code> - async pulse execution with error handling</li> <li>Handles prompt building with sticky notes via PulseExecutor</li> <li>Graceful shutdown (SIGTERM/SIGINT) with 30-second grace period</li> <li> <p>See Daemon &amp; API</p> </li> <li> <p>Logging (<code>src/reeve/utils/logging.py</code>) \u2705</p> </li> <li>Implemented <code>setup_logging()</code> function (72 lines)</li> <li>RotatingFileHandler with 10MB max, 5 backups</li> <li>Structured logging format</li> <li> <p>Console + file output (configurable)</p> </li> <li> <p>Entry Point (<code>src/reeve/pulse/__main__.py</code>) \u2705</p> </li> <li>Implemented module entry point (59 lines)</li> <li>Configuration loading and logging setup</li> <li> <p>Graceful KeyboardInterrupt handling</p> </li> <li> <p>Testing \u2705</p> </li> <li>21 comprehensive unit tests (tests/test_pulse_daemon.py)</li> <li>2 integration/validation tests (tests/test_phase5_validation.py)</li> <li>All tests pass: 94/94</li> </ol>"},{"location":"roadmap/phase-5-daemon/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Functional daemon process</li> <li>\u2705 Pulse execution working end-to-end</li> <li>\u2705 Proper logging with file rotation</li> <li>\u2705 Comprehensive test suite</li> </ul>"},{"location":"roadmap/phase-5-daemon/#validation","title":"Validation","text":"<pre><code># Terminal 1: Start daemon\nuv run python -m reeve.pulse\n\n# Terminal 2: Schedule pulse via MCP (in Claude Code)\nschedule_pulse(\n    scheduled_at=\"in 10 seconds\",\n    prompt=\"Test pulse execution\",\n    priority=\"high\"\n)\n\n# Terminal 1: Watch logs for execution\n# Should see: \"Executing pulse X: Test pulse execution...\"\n# Should see: \"Pulse X completed successfully in Yms\"\n</code></pre>"},{"location":"roadmap/phase-5-daemon/#demo","title":"Demo","text":""},{"location":"roadmap/phase-5-daemon/#step-1-start-the-daemon","title":"Step 1: Start the daemon","text":"<pre><code># Terminal 1: Start daemon in foreground\nuv run python -m reeve.pulse\n\n# Expected output:\n# 2026-01-19 10:30:00 | INFO | Starting Pulse Daemon...\n# 2026-01-19 10:30:00 | INFO | Database: ~/.reeve/pulse_queue.db\n# 2026-01-19 10:30:00 | INFO | Scheduler loop started (polling every 1s)\n# 2026-01-19 10:30:00 | INFO | Ready to execute pulses\n</code></pre>"},{"location":"roadmap/phase-5-daemon/#step-2-schedule-pulses-via-mcp-in-claude-code-or-via-demo-script","title":"Step 2: Schedule pulses via MCP (in Claude Code or via demo script)","text":"<pre><code># Terminal 2: Run the demo script\nuv run python demos/phase5_daemon_demo.py\n\n# The script will:\n# 1. Schedule 3 pulses with different priorities and timing\n# 2. Watch the daemon execute them in priority order\n# 3. Verify retry logic on simulated failures\n# 4. Test graceful shutdown\n</code></pre>"},{"location":"roadmap/phase-5-daemon/#expected-daemon-output","title":"Expected daemon output","text":"<pre><code>2026-01-19 10:30:05 | INFO | Found 3 due pulses\n2026-01-19 10:30:05 | INFO | Executing pulse #1 (CRITICAL): \"Emergency system check\"\n2026-01-19 10:30:05 | INFO | Launching Hapi session...\n2026-01-19 10:30:08 | INFO | Pulse #1 completed successfully (3.2s)\n2026-01-19 10:30:10 | INFO | Executing pulse #2 (HIGH): \"Morning briefing\"\n2026-01-19 10:30:10 | INFO | Launching Hapi session...\n2026-01-19 10:30:13 | INFO | Pulse #2 completed successfully (2.8s)\n2026-01-19 10:30:15 | INFO | Executing pulse #3 (NORMAL): \"Check calendar\"\n2026-01-19 10:30:15 | INFO | Launching Hapi session...\n2026-01-19 10:30:18 | INFO | Pulse #3 completed successfully (2.1s)\n</code></pre>"},{"location":"roadmap/phase-5-daemon/#step-3-test-retry-logic","title":"Step 3: Test retry logic","text":"<pre><code># The demo script will schedule a pulse that intentionally fails\n# Expected daemon output:\n2026-01-19 10:31:00 | INFO | Executing pulse #4 (HIGH): \"Flaky task\"\n2026-01-19 10:31:00 | INFO | Launching Hapi session...\n2026-01-19 10:31:02 | ERROR | Pulse #4 failed: Hapi returned error code 1\n2026-01-19 10:31:02 | INFO | Scheduling retry #1 in 2 minutes\n2026-01-19 10:33:02 | INFO | Executing pulse #5 (HIGH): \"Flaky task (retry 1)\"\n2026-01-19 10:33:02 | INFO | Launching Hapi session...\n2026-01-19 10:33:05 | INFO | Pulse #5 completed successfully (2.5s)\n</code></pre>"},{"location":"roadmap/phase-5-daemon/#step-4-test-graceful-shutdown","title":"Step 4: Test graceful shutdown","text":"<pre><code># In Terminal 1, press Ctrl+C\n^C2026-01-19 10:35:00 | INFO | Received shutdown signal\n2026-01-19 10:35:00 | INFO | Waiting for 1 running pulse to complete...\n2026-01-19 10:35:02 | INFO | All pulses completed\n2026-01-19 10:35:02 | INFO | Daemon shut down gracefully\n</code></pre> <p>Previous: Phase 4: Pulse Executor</p> <p>Next: Phase 6: HTTP API</p>"},{"location":"roadmap/phase-6-api/","title":"Phase 6 - API","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-6-api/#phase-6-http-api-completed","title":"Phase 6: HTTP API \u2705 COMPLETED","text":"<p>Goal: Allow external systems to trigger pulses.</p> <p>Status: \u2705 Completed</p>"},{"location":"roadmap/phase-6-api/#tasks","title":"Tasks","text":"<ol> <li>FastAPI Server (<code>src/reeve/api/server.py</code>) \u2705</li> <li>Implemented <code>create_app()</code> factory function (295 lines)</li> <li>Implemented endpoints:<ul> <li><code>POST /api/pulse/schedule</code> - Create pulse \u2705</li> <li><code>GET /api/pulse/upcoming</code> - List pulses \u2705</li> <li><code>GET /api/health</code> - Health check (no auth) \u2705</li> <li><code>GET /api/status</code> - Daemon status \u2705</li> </ul> </li> <li>Bearer token authentication with custom dependency \u2705</li> <li>Pydantic models for request/response validation \u2705</li> <li>Flexible time parsing via <code>parse_time_string()</code> utility \u2705</li> <li> <p>See Daemon &amp; API</p> </li> <li> <p>Integrate with Daemon \u2705</p> </li> <li>Integrated API server in <code>__main__.py</code> \u2705</li> <li>API runs concurrently with scheduler using asyncio \u2705</li> <li>Shared PulseQueue instance for database access \u2705</li> <li> <p>Graceful shutdown handling for both components \u2705</p> </li> <li> <p>Time Parsing Utility (<code>src/reeve/utils/time_parser.py</code>) \u2705</p> </li> <li>Extracted shared time parsing logic (79 lines) \u2705</li> <li>Used by both MCP server and API server \u2705</li> <li> <p>Supports ISO 8601, relative times, and keywords \u2705</p> </li> <li> <p>Testing \u2705</p> </li> <li>8 comprehensive unit tests (<code>tests/test_api_server.py</code>) \u2705</li> <li>All endpoint tests (schedule, list, health, status) \u2705</li> <li>Authentication tests (valid, invalid, missing) \u2705</li> <li> <p>All tests pass: 154/154 \u2705</p> </li> <li> <p>Demo Script (<code>demos/phase6_api_demo.py</code>) \u2705</p> </li> <li>8 comprehensive demo functions (418 lines) \u2705</li> <li>Health check, authentication, schedule (now/relative/ISO), list, status, cleanup \u2705</li> <li>Uses httpx for async HTTP requests \u2705</li> <li>Interactive flow with daemon running check \u2705</li> </ol>"},{"location":"roadmap/phase-6-api/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Working REST API with 4 endpoints</li> <li>\u2705 API runs alongside daemon concurrently</li> <li>\u2705 Bearer token authentication working</li> <li>\u2705 Comprehensive test suite and demo script</li> </ul>"},{"location":"roadmap/phase-6-api/#validation","title":"Validation","text":"<pre><code># Start daemon (includes API)\nuv run python -m reeve.pulse\n\n# Test health endpoint\ncurl http://localhost:8765/api/health\n\n# Trigger pulse\ncurl -X POST http://localhost:8765/api/pulse/trigger \\\n  -H \"Authorization: Bearer your_token\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"prompt\": \"Test from API\",\n    \"scheduled_at\": \"now\",\n    \"priority\": \"high\",\n    \"source\": \"curl\"\n  }'\n\n# List upcoming\ncurl -H \"Authorization: Bearer your_token\" \\\n  http://localhost:8765/api/pulse/upcoming?limit=10\n</code></pre>"},{"location":"roadmap/phase-6-api/#demo","title":"Demo","text":""},{"location":"roadmap/phase-6-api/#prerequisites","title":"Prerequisites","text":"<pre><code># Set API token in .env file\necho \"PULSE_API_TOKEN=your_secret_token_here\" &gt;&gt; .env\n</code></pre>"},{"location":"roadmap/phase-6-api/#step-1-start-daemon-with-api-terminal-1","title":"Step 1: Start daemon with API (Terminal 1)","text":"<pre><code>uv run python -m reeve.pulse\n\n# Expected output:\n# 2026-01-19 10:30:00 | INFO | Starting Pulse Daemon...\n# 2026-01-19 10:30:00 | INFO | Starting HTTP API on port 8765...\n# 2026-01-19 10:30:00 | INFO | API docs available at http://localhost:8765/docs\n# 2026-01-19 10:30:00 | INFO | Scheduler loop started\n</code></pre>"},{"location":"roadmap/phase-6-api/#step-2-run-demo-script-terminal-2","title":"Step 2: Run demo script (Terminal 2)","text":"<pre><code>uv run python demos/phase6_api_demo.py\n\n# The script will test all API endpoints:\n# \u2713 Health check\n# \u2713 Status endpoint\n# \u2713 Trigger pulse (immediate)\n# \u2713 Trigger pulse (scheduled)\n# \u2713 List upcoming pulses\n# \u2713 Authentication (valid token)\n# \u2713 Authentication (invalid token - should fail)\n#\n# Expected output:\n# \u2713 Health check: {\"status\": \"healthy\", \"version\": \"0.1.0\"}\n# \u2713 Status: {\"daemon_uptime\": \"5m\", \"pulses_executed\": 42, \"pending\": 3}\n# \u2713 Triggered immediate pulse: {\"pulse_id\": 123, \"scheduled_at\": \"now\"}\n# \u2713 Triggered scheduled pulse: {\"pulse_id\": 124, \"scheduled_at\": \"2026-01-19T11:00:00Z\"}\n# \u2713 Listed 2 upcoming pulses\n# \u2713 Invalid token rejected with 401\n# \u2713 Phase 6 Demo Complete!\n</code></pre>"},{"location":"roadmap/phase-6-api/#step-3-manual-curl-testing","title":"Step 3: Manual curl testing","text":"<pre><code># Health check (no auth required)\ncurl http://localhost:8765/api/health\n\n# Trigger a pulse\ncurl -X POST http://localhost:8765/api/pulse/trigger \\\n  -H \"Authorization: Bearer your_secret_token_here\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"prompt\": \"Check my calendar and send me a summary\",\n    \"scheduled_at\": \"now\",\n    \"priority\": \"high\",\n    \"source\": \"manual_curl\"\n  }'\n\n# Expected response:\n# {\"pulse_id\": 125, \"scheduled_at\": \"2026-01-19T10:30:15Z\", \"status\": \"pending\"}\n\n# Watch Terminal 1 (daemon logs):\n# 2026-01-19 10:30:15 | INFO | API: Received pulse trigger from manual_curl\n# 2026-01-19 10:30:15 | INFO | Executing pulse #125 (HIGH): \"Check my calendar...\"\n# 2026-01-19 10:30:18 | INFO | Pulse #125 completed successfully (2.8s)\n</code></pre>"},{"location":"roadmap/phase-6-api/#step-4-explore-api-docs","title":"Step 4: Explore API docs","text":"<pre><code># Open browser to http://localhost:8765/docs\n# FastAPI provides interactive Swagger UI for testing all endpoints\n</code></pre> <p>Previous: Phase 5: Daemon</p> <p>Next: Phase 7: Telegram Integration</p>"},{"location":"roadmap/phase-7-telegram/","title":"Phase 7 - Telegram","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-7-telegram/#phase-7-telegram-integration-completed","title":"Phase 7: Telegram Integration \u2705 COMPLETED","text":"<p>Goal: Migrate Telegram listener to use new architecture.</p> <p>Status: \u2705 Completed</p>"},{"location":"roadmap/phase-7-telegram/#tasks","title":"Tasks","text":"<ol> <li>New Telegram Listener (<code>src/reeve/integrations/telegram/listener.py</code>) \u2705</li> <li>Implemented <code>TelegramListener</code> class (595 lines)</li> <li>Async polling-based integration with Telegram Bot API</li> <li>Long polling (100s timeout) for efficient resource usage</li> <li>Offset persistence to prevent duplicate message processing</li> <li>Chat ID filtering (only processes authorized user)</li> <li>Exponential backoff error handling (up to 5 minutes)</li> <li> <p>See Daemon &amp; API</p> </li> <li> <p>Testing \u2705</p> </li> <li>35 comprehensive unit tests (<code>tests/test_telegram_listener.py</code>)</li> <li>2 integration/validation tests (<code>tests/test_phase7_validation.py</code>)</li> <li> <p>All tests pass: 191/191</p> </li> <li> <p>Entry Point (<code>src/reeve/integrations/telegram/__main__.py</code>) \u2705</p> </li> <li>Run as module: <code>python -m reeve.integrations.telegram</code></li> <li>Configuration loading and validation</li> <li>Graceful KeyboardInterrupt handling</li> </ol>"},{"location":"roadmap/phase-7-telegram/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Production-ready Telegram listener</li> <li>\u2705 End-to-end message flow working</li> <li>\u2705 Comprehensive test suite</li> </ul>"},{"location":"roadmap/phase-7-telegram/#validation","title":"Validation","text":"<pre><code># Terminal 1: Start daemon\nuv run python -m reeve.pulse\n\n# Terminal 2: Start Telegram listener\nuv run python -m reeve.integrations.telegram\n\n# Terminal 3: Send Telegram message\n# Should see:\n# - Listener: \"\ud83d\udce9 Telegram message from User: hello\"\n# - Listener: \"\u2713 Pulse 123 triggered\"\n# - Daemon: \"Executing pulse 123: Telegram message from User: hello\"\n# - Daemon: \"Pulse 123 completed successfully\"\n</code></pre>"},{"location":"roadmap/phase-7-telegram/#demo","title":"Demo","text":""},{"location":"roadmap/phase-7-telegram/#prerequisites","title":"Prerequisites","text":"<pre><code># Ensure Telegram credentials are in .env\n# TELEGRAM_BOT_TOKEN=your_bot_token\n# TELEGRAM_CHAT_ID=your_chat_id\n# PULSE_API_TOKEN=your_secret_token\n</code></pre>"},{"location":"roadmap/phase-7-telegram/#step-1-start-daemon-terminal-1","title":"Step 1: Start daemon (Terminal 1)","text":"<pre><code>uv run python -m reeve.pulse\n\n# Expected output:\n# 2026-01-19 10:30:00 | INFO | Starting Pulse Daemon...\n# 2026-01-19 10:30:00 | INFO | Starting HTTP API on port 8765...\n# 2026-01-19 10:30:00 | INFO | Scheduler loop started\n</code></pre>"},{"location":"roadmap/phase-7-telegram/#step-2-start-telegram-listener-terminal-2","title":"Step 2: Start Telegram listener (Terminal 2)","text":"<pre><code>uv run python -m reeve.integrations.telegram\n\n# Expected output:\n# 2026-01-19 10:30:05 | INFO | Starting Telegram Listener...\n# 2026-01-19 10:30:05 | INFO | Bot username: @YourBotName\n# 2026-01-19 10:30:05 | INFO | Listening for messages from chat_id: 123456789\n# 2026-01-19 10:30:05 | INFO | Polling for updates...\n</code></pre>"},{"location":"roadmap/phase-7-telegram/#step-3-run-demo-script-terminal-3","title":"Step 3: Run demo script (Terminal 3)","text":"<pre><code>uv run python demos/phase7_telegram_demo.py\n\n# The script will:\n# 1. Send a test message to the bot\n# 2. Verify the listener receives it\n# 3. Verify a pulse is triggered via API\n# 4. Verify the daemon executes it\n# 5. Verify Reeve responds back via Telegram\n</code></pre>"},{"location":"roadmap/phase-7-telegram/#expected-output-across-terminals","title":"Expected output across terminals","text":"<p>Terminal 2 (Telegram Listener): <pre><code>2026-01-19 10:30:10 | INFO | \ud83d\udce9 Telegram message from User (123456789): hello\n2026-01-19 10:30:10 | INFO | Triggering pulse via API...\n2026-01-19 10:30:10 | INFO | \u2713 Pulse 42 triggered\n</code></pre></p> <p>Terminal 1 (Daemon): <pre><code>2026-01-19 10:30:10 | INFO | API: Received pulse trigger from telegram\n2026-01-19 10:30:10 | INFO | Executing pulse #42 (CRITICAL): \"Telegram message from User: hello\"\n2026-01-19 10:30:10 | INFO | Launching Hapi session...\n2026-01-19 10:30:13 | INFO | Pulse #42 completed successfully (3.1s)\n</code></pre></p> <p>Your Telegram App: <pre><code>[Your message]\nhello\n\n[Bot's response]\nHi! I received your message. How can I help you today?\n\n\ud83d\udcac View in Claude Code: https://hapi.example.com/session/abc123\n</code></pre></p>"},{"location":"roadmap/phase-7-telegram/#step-4-test-complex-interactions","title":"Step 4: Test complex interactions","text":"<pre><code># Send: \"What's on my calendar today?\"\n# Expected: Bot responds with your calendar summary\n\n# Send: \"Remind me to call John in 2 hours\"\n# Expected: Bot confirms and schedules a pulse\n\n# Send: \"What's the weather like?\"\n# Expected: Bot fetches weather and responds\n</code></pre> <p>Previous: Phase 6: HTTP API</p> <p>Next: Phase 8: Deployment</p>"},{"location":"roadmap/phase-8-deployment/","title":"Phase 8 - Deployment","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-8-deployment/#phase-8-deployment-completed","title":"Phase 8: Deployment \u2705 COMPLETED","text":"<p>Goal: Production deployment with systemd.</p> <p>Status: \u2705 Completed</p>"},{"location":"roadmap/phase-8-deployment/#deliverables","title":"Deliverables","text":"<ul> <li>\u2705 Daemon running as systemd service</li> <li>\u2705 Telegram listener as systemd service</li> <li>\u2705 Monitoring and backups configured</li> <li>\u2705 Complete deployment documentation</li> </ul>"},{"location":"roadmap/phase-8-deployment/#implementation-summary","title":"Implementation Summary","text":""},{"location":"roadmap/phase-8-deployment/#deploy-directory-structure","title":"Deploy Directory Structure","text":"<pre><code>deploy/\n\u251c\u2500\u2500 README.md                           # Quick-reference guide\n\u251c\u2500\u2500 systemd/\n\u2502   \u251c\u2500\u2500 reeve-daemon.service.template   # Pulse daemon service\n\u2502   \u2514\u2500\u2500 reeve-telegram.service.template # Telegram listener service\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 logrotate.conf.template         # Log rotation config\n\u251c\u2500\u2500 credential-providers/\n\u2502   \u2514\u2500\u2500 claude-code.sh                  # Claude Code OAuth token provider\n\u251c\u2500\u2500 cron/\n\u2502   \u2514\u2500\u2500 reeve.cron.template             # Scheduled tasks (heartbeat, health, backup, credentials)\n\u2514\u2500\u2500 scripts/\n    \u251c\u2500\u2500 install.sh                      # Main installation script\n    \u251c\u2500\u2500 uninstall.sh                    # Cleanup script\n    \u251c\u2500\u2500 reeve-heartbeat.sh              # Hourly heartbeat pulse\n    \u251c\u2500\u2500 reeve-health-check.sh           # Health check helper\n    \u251c\u2500\u2500 reeve-backup.sh                 # Database backup helper\n    \u2514\u2500\u2500 reeve-credential-keepalive.sh   # Credential refresh orchestrator\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#template-variables","title":"Template Variables","text":"<p>Templates use <code>{{VAR}}</code> syntax, replaced during installation:</p> Variable Description <code>{{USER}}</code> Service user <code>{{REEVE_BOT_PATH}}</code> Repo path <code>{{REEVE_HOME}}</code> Data directory <code>{{REEVE_DESK_PATH}}</code> User's Desk repo <code>{{UV_PATH}}</code> uv binary path"},{"location":"roadmap/phase-8-deployment/#quick-install","title":"Quick Install","text":"<pre><code>sudo ./deploy/scripts/install.sh\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#quick-uninstall","title":"Quick Uninstall","text":"<pre><code>sudo ./deploy/scripts/uninstall.sh\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#validation","title":"Validation","text":"<pre><code># Check services\nsudo systemctl status reeve-daemon\nsudo systemctl status reeve-telegram\n\n# Test end-to-end\n# Send Telegram message \u2192 Reeve responds\n\n# Check logs\nsudo journalctl -u reeve-daemon -f\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#demo","title":"Demo","text":""},{"location":"roadmap/phase-8-deployment/#step-1-install-as-systemd-services","title":"Step 1: Install as systemd services","text":"<pre><code># Run the deployment script\nsudo bash demos/phase8_deployment_demo.sh\n\n# Expected output:\n# \u2713 Created systemd service: reeve-daemon.service\n# \u2713 Created systemd service: reeve-telegram.service\n# \u2713 Reloaded systemd daemon\n# \u2713 Enabled reeve-daemon.service\n# \u2713 Enabled reeve-telegram.service\n# \u2713 Started reeve-daemon.service\n# \u2713 Started reeve-telegram.service\n# \u2713 Services are running\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#step-2-verify-services-are-running","title":"Step 2: Verify services are running","text":"<pre><code>sudo systemctl status reeve-daemon\n\n# Expected output:\n# \u25cf reeve-daemon.service - Reeve Pulse Queue Daemon\n#    Loaded: loaded (/etc/systemd/system/reeve-daemon.service; enabled)\n#    Active: active (running) since Sun 2026-01-19 10:30:00 UTC; 5min ago\n#    Main PID: 12345 (python)\n#    Tasks: 3 (limit: 4915)\n#    Memory: 45.2M\n#    CGroup: /system.slice/reeve-daemon.service\n#            \u2514\u250012345 /usr/bin/python -m reeve.pulse\n#\n# Jan 19 10:30:00 hostname systemd[1]: Started Reeve Pulse Queue Daemon\n# Jan 19 10:30:00 hostname python[12345]: INFO | Starting Pulse Daemon...\n# Jan 19 10:30:00 hostname python[12345]: INFO | Scheduler loop started\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#step-3-test-end-to-end-functionality","title":"Step 3: Test end-to-end functionality","text":"<pre><code># Send a Telegram message\n# Expected: Bot responds within a few seconds\n\n# Check daemon logs\nsudo journalctl -u reeve-daemon -n 50\n\n# Expected to see pulse execution logs\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#step-4-test-automatic-restart","title":"Step 4: Test automatic restart","text":"<pre><code># Simulate a crash\nsudo kill -9 $(pgrep -f \"reeve.pulse.daemon\")\n\n# Wait a few seconds, then check status\nsleep 5\nsudo systemctl status reeve-daemon\n\n# Expected: Service should auto-restart\n# Active: active (running) since Sun 2026-01-19 10:35:15 UTC; 2s ago\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#step-5-verify-monitoring-and-backups","title":"Step 5: Verify monitoring and backups","text":"<pre><code># Check log rotation\nls -lh /var/log/reeve/\n\n# Check database backup\nls -lh ~/.reeve/backups/\n\n# Check cron jobs\ncrontab -l | grep reeve\n\n# Expected:\n# 0 * * * * /usr/local/bin/reeve-heartbeat ...    (hourly heartbeat)\n# */5 * * * * /usr/local/bin/reeve-health-check ... (health check)\n# 0 3 * * * /usr/local/bin/reeve-backup ...       (daily backup)\n# 0 */4 * * * /usr/local/bin/reeve-credential-keepalive ... (credential keep-alive)\n</code></pre>"},{"location":"roadmap/phase-8-deployment/#step-6-graceful-shutdown-test","title":"Step 6: Graceful shutdown test","text":"<pre><code># Stop services\nsudo systemctl stop reeve-daemon\nsudo systemctl stop reeve-telegram\n\n# Verify they stopped cleanly\nsudo journalctl -u reeve-daemon -n 10\n\n# Expected to see graceful shutdown logs:\n# Jan 19 10:40:00 hostname python[12345]: INFO | Received shutdown signal\n# Jan 19 10:40:00 hostname python[12345]: INFO | Waiting for running pulses...\n# Jan 19 10:40:02 hostname python[12345]: INFO | Daemon shut down gracefully\n</code></pre> <p>Previous: Phase 7: Telegram Integration</p> <p>Next: Phase 9: Integration Testing &amp; Polish</p>"},{"location":"roadmap/phase-9-testing/","title":"Phase 9 - Testing","text":"<p>\u2190 Back to Roadmap Index</p>"},{"location":"roadmap/phase-9-testing/#phase-9-integration-testing-polish-pending","title":"Phase 9: Integration Testing &amp; Polish \u23f3 PENDING","text":"<p>Goal: Ensure everything works together reliably.</p> <p>Status: \u23f3 Pending</p>"},{"location":"roadmap/phase-9-testing/#tasks","title":"Tasks","text":"<ol> <li>Integration Test Suite</li> <li>Write end-to-end tests covering full flow:<ul> <li>MCP \u2192 Queue \u2192 Execution</li> <li>External trigger \u2192 API \u2192 Queue \u2192 Execution</li> <li>Telegram \u2192 API \u2192 Queue \u2192 Execution \u2192 Response</li> </ul> </li> <li>Test failure scenarios (Hapi crash, DB lock, etc.)</li> <li> <p>Test retry logic</p> </li> <li> <p>Performance Testing</p> </li> <li>Load test: 1000 pulses scheduled simultaneously</li> <li>Measure execution latency</li> <li> <p>Optimize slow queries</p> </li> <li> <p>Documentation</p> </li> <li>Update README.md with architecture diagram</li> <li>Add usage examples</li> <li> <p>Document common workflows</p> </li> <li> <p>Edge Cases</p> </li> <li>Test timezone handling</li> <li>Test very long prompts (&gt;1000 chars)</li> <li>Test rapid pulse scheduling</li> <li>Test database recovery after crash</li> </ol>"},{"location":"roadmap/phase-9-testing/#deliverables","title":"Deliverables","text":"<ul> <li>\u23f3 Comprehensive test suite</li> <li>\u23f3 Performance benchmarks</li> <li>\u23f3 Updated documentation</li> <li>\u23f3 Hardened error handling</li> </ul> <p>Previous: Phase 8: Deployment</p>"}]}